#собеседование #базы #данные 



# SQL
## Вопросы
	 **Чем отличаются PRIMARY KEY и UNIQUE KEY?**

- **Ответ:** PRIMARY KEY и UNIQUE KEY оба гарантируют уникальность значений в столбце или наборе столбцов. Основное различие заключается в том, что PRIMARY KEY автоматически создает индекс для уникальности и не допускает NULL значений, в то время как UNIQUE KEY также гарантирует уникальность, но позволяет NULL значениям (если не определено иное).
- **Что такое JOIN в SQL и какие типы JOIN существуют?**
    
    - **Ответ:** JOIN это оператор SQL, используемый для объединения строк из двух или более таблиц на основе связанного столбца. Основные типы JOIN: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN, CROSS JOIN.
- **Что такое индекс кластеризации (clustered index)?**
    
    - **Ответ:** Индекс кластеризации сортирует и сохраняет данные строк таблицы на диске в порядке, определенном индексом. У каждой таблицы может быть только один кластерный индекс, так как строки таблицы могут быть отсортированы только одним способом.
- **Что такое внешние ключи (foreign keys)?**
    
    - **Ответ:** Внешний ключ это столбец или набор столбцов, которые создают связь между данными в двух таблицах. Внешний ключ указывает на PRIMARY KEY в другой таблице и обеспечивает ссылочную целостность между таблицами.
- **Как работает команда `GROUP BY` в SQL?**
    
    - **Ответ:** Команда `GROUP BY` используется для группировки строк, имеющих одинаковые значения в указанных столбцах. Это позволяет применять агрегатные функции, такие как `COUNT`, `SUM`, `AVG`, `MAX` и `MIN` к каждой группе.
- **Что такое нормализация базы данных и какие формы нормализации существуют?**
    
    - **Ответ:** Нормализация это процесс структурирования базы данных для минимизации избыточности и зависимости. Основные формы нормализации: 1NF (первая нормальная форма), 2NF (вторая нормальная форма), 3NF (третья нормальная форма), BCNF (нормальная форма Бойса-Кодда), 4NF (четвертая нормальная форма) и 5NF (пятая нормальная форма).
- **Что такое подзапрос (subquery) в SQL?**
    
    - **Ответ:** Подзапрос это запрос, вложенный внутри другого запроса. Подзапрос может использоваться в SELECT, INSERT, UPDATE или DELETE операциях и позволяет извлекать данные, которые будут использованы в основном запросе.
- **Что такое `HAVING` и чем он отличается от `WHERE`?**
    
    - **Ответ:** `HAVING` используется для фильтрации результатов, полученных с помощью агрегатных функций и `GROUP BY`, в то время как `WHERE` используется для фильтрации строк до агрегатирования.
- **Что такое оптимизация запросов?**
    
    - **Ответ:** Оптимизация запросов это процесс улучшения производительности SQL-запросов путем минимизации времени их выполнения. Это достигается с помощью индексов, анализа плана выполнения запросов, изменения структуры запросов и других методов.
- **Что такое VIEW в SQL и для чего он используется?**
    
    - **Ответ:** VIEW (представление) это виртуальная таблица, основанная на результате SQL-запроса. Представления используются для упрощения сложных запросов, обеспечения безопасности и представления данных в удобном для пользователей виде.
    
- **Что такое SQL и какие типы команд в нем существуют?**
    
    - SQL (Structured Query Language) — это язык структурированных запросов, используемый для работы с реляционными базами данных.
    - Основные типы команд в SQL:
        - **DDL (Data Definition Language)**: команды для определения структуры базы данных, такие как `CREATE`, `ALTER`, `DROP`.
        - **DML (Data Manipulation Language)**: команды для манипулирования данными, например, `INSERT`, `UPDATE`, `DELETE`.
        - **DQL (Data Query Language)**: команды для извлечения данных, такие как `SELECT`.
        - **DCL (Data Control Language)**: команды для управления доступом к данным, например, `GRANT`, `REVOKE`.
- **Чем отличается `INNER JOIN` от `LEFT JOIN`?**
    
    - `INNER JOIN` возвращает строки, имеющие соответствия в обеих таблицах, на основании условия соединения.
    - `LEFT JOIN` (или `LEFT OUTER JOIN`) возвращает все строки из левой таблицы и соответствующие строки из правой таблицы, если они есть, иначе NULL.
### Что такое первичный ключ в SQL и почему он важен?

В SQL первичный ключ – это поле или комбинация полей, которые однозначно идентифицируют определенную строку в таблице. Первичный ключ важен, потому что он гарантирует отсутствие дубликатов строк в таблице, а также позволяет эффективно выполнять запросы и индексировать таблицу.

Например, у вас есть таблица сотрудников, и вы хотите, чтобы у каждого сотрудника был уникальный идентификатор. Вы можете создать поле первичного ключа под названием “employee_id”. Это поле будет целым числом, которое увеличивается на единицу для каждого нового сотрудника, добавленного в таблицу. При создании первичного ключа вы также установите ограничение, которое гарантирует, что поле “employee_id” не будет содержать нулевых значений или дубликатов.

Наличие первичного ключа также позволяет эффективно индексировать таблицу, что повышает производительность запросов. Когда вы запрашиваете таблицу с помощью первичного ключа, механизм базы данных может быстро найти нужную строку без сканирования всей таблицы.

В целом, первичный ключ – важнейший компонент хорошо продуманной схемы базы данных, поскольку он обеспечивает целостность данных и позволяет эффективно выполнять запросы и индексирование
### Что такое внешний ключ и как он используется для установления связей между таблицами?

Внешний ключ – это столбец или набор столбцов, которые ссылаются на первичный ключ другой таблицы. Он используется для установления связи между двумя таблицами.

Добавление внешнего ключа в таблицу создает связь между данными в этой таблице и данными в другой таблице. Эта связь гарантирует, что данные в двух таблицах всегда будут соответствовать друг другу.

Допустим, у нас есть две таблицы: одна для заказов, другая для клиентов. Мы можем создать внешний ключ в таблице заказов, который будет ссылаться на идентификатор клиента в таблице клиентов. Это установит связь между двумя таблицами на основе идентификатора клиента.
### В чем разница между базой данных и схемой?

В SQL база данных – это набор связанных данных, которые хранятся в организованном структурированном виде. Обычно она содержит одну или несколько таблиц, а также другие объекты, такие как представления, хранимые процедуры и индексы. А схема – это контейнер для объектов базы данных, включая таблицы, представления и хранимые процедуры.

База данных может иметь несколько схем, причем каждая схема будет содержать подмножество объектов базы данных. Схема позволяет логически сгруппировать связанные объекты и отделить их от других объектов в той же базе данных. Это может помочь в организации, обеспечении безопасности и контроле доступа.

Например, представьте себе базу данных для розничного магазина. В ней может быть несколько схем для различных отделов, таких как отдел продаж, отдел инвентаризации и отдел кадров. Каждая схема будет содержать таблицы и другие объекты, относящиеся к данному отделу. Это облегчит управление базой данных и обеспечит доступ только к соответствующим данным для каждого отдела.

В общем, база данных – это хранилище для всех данных и объектов, а схема – это контейнер для подмножества этих объектов, обеспечивающий организацию и разделение задач.
### Что такое выражение GROUP BY и как оно используется?

Выражение GROUP BY – это оператор SQL, используемый для группировки строк с одинаковыми значениями в одном или нескольких столбцах в итоговые строки, например, “найти общий объем продаж для каждого продукта”.

Оператор GROUP BY используется вместе с оператором SELECT и требует, чтобы в операторе SELECT использовалась хотя бы одна агрегатная функция, например SUM, COUNT, AVG, MAX или MIN. За оператором GROUP BY обычно следует имя (имена) столбца (столбцов), по которым необходимо сгруппировать данные.
### Что такое self-join и когда используется?

Self-join в SQL – это тип операции соединения, при которой таблица объединяется сама с собой. Это полезно, когда у вас есть таблица со связанными данными в разных строках, которые вы хотите объединить на основе общего поля.

Например, рассмотрим таблицу “employees” (“Сотрудники”) со столбцами для ID и имени сотрудника, а также ID менеджера. Столбец ID менеджера содержит ID менеджера сотрудника. Чтобы получить список всех сотрудников с именем их менеджера, можно использовать self-join.
### В чем разница между внутренним и внешним соединением?

Cоединения (joins, джоины) используются для комбинации данных из нескольких таблиц на основе общего столбца или их взаимоотношений. Два наиболее распространенных типа соединений – это внутреннее (inner join) и внешнее (outer join) соединения.

Внутреннее соединение возвращает только совпадающие строки из обеих таблиц на основе условия соединения. Например, если у нас есть две таблицы A и B, и мы выполняем внутреннее объединение с использованием общего столбца C, будут возвращены только те строки, в которых C совпадает в обеих таблицах.
### В чем разница между операторами DELETE и TRUNCATE?

Операторы DELETE и TRUNCATE используются для удаления данных из таблицы. При этом они отличаются по своей функциональности и влиянию на таблицу.

Оператор DELETE используется для удаления определенных строк из таблицы на основе условия, указанного в предложении WHERE. Он также может использоваться для удаления всех строк из таблицы без указания условия. Оператор DELETE удаляет строки по одной, что может быть медленным процессом для больших таблиц.

Оператор TRUNCATE используется для удаления всех строк из таблицы за один раз. Это более быстрый метод удаления данных по сравнению с DELETE. Однако, TRUNCATE не позволяет использовать предложение WHERE и не может выборочно удалять определенные строки.

Еще одно различие между DELETE и TRUNCATE заключается в том, что DELETE можно откатить с помощью журнала транзакций, а TRUNCATE – нет. После выполнения оператора TRUNCATE данные удаляются из таблицы навсегда.

В общем, если вы хотите выборочно удалить определенные строки из таблицы или откатить изменения, используйте оператор DELETE. Если нужно удалить все строки из таблицы и освободить дисковое пространство, используемое таблицей, следует использовать оператор TRUNCATE.
### Что такое временная таблица и как она используется?

Временная таблица – это тип таблицы, которая создается и существует только на время сеанса или транзакции. Она не хранится в базе данных постоянно и удаляется автоматически.

Временные таблицы можно использовать для хранения промежуточных результатов или для разбиения сложных запросов на более простые шаги. Они особенно полезны, когда запрос требует нескольких шагов или сложных вычислений, так как помогают повысить производительность запроса и упростить его синтаксис.

Временные таблицы можно создать с помощью оператора CREATE TEMPORARY TABLE. Они могут быть созданы в памяти или на диске, в зависимости от системы базы данных и конфигурации.

Временные таблицы можно использовать как обычные таблицы в SQL-запросах и заполнять данными с помощью операторов INSERT. Их также можно объединять с другими таблицами или использовать в подзапросах.

Одним из распространенных вариантов использования временных таблиц является хранение и обработка промежуточных результатов в сложных запросах, особенно в тех, которые включают соединения или агрегирование. Например, временная таблица может использоваться для хранения результатов операции соединения, которые затем могут быть использованы для дальнейших манипуляций или соединения с другими таблицами на последующих этапах запроса.
### В чем разница между предложениями HAVING и WHERE?

В SQL для фильтрации данных в запросе используются как предложения HAVING, так и WHERE. Однако между ними есть некоторые различия.

Предложение WHERE используется для фильтрации данных перед их группировкой или агрегированием и применяется в операторах SELECT, UPDATE и DELETE. Оно фильтрует данные на основе условий, которые применяются к отдельным строкам.
### Что такое оконная функция и как она используется?

Оконная функция – это тип функции в SQL, которая выполняет вычисления для набора строк в определенном “окне” или диапазоне. Она используется для решения сложных аналитических задач, которые не могут быть легко решены с помощью простых агрегатных функций.

Оконные функции могут использоваться для выполнения таких вычислений, как скользящие средние, промежуточные итоги, ранжирование, нумерация строк и процент от общего числа. Они работают с подмножеством строк, определяемым предложением OVER(), которое задает окно или диапазон для функции.
### В чем разница между транзакцией и batch?

В SQL транзакция – это единая логическая единица работы, включающая один или несколько операторов SQL. Транзакция выполняется атомарно. Это значит, что все операторы внутри транзакции должны быть либо зафиксированы, либо отменены как единое целое.

Транзакции обеспечивают согласованность и целостность данных в базе, позволяя группировать несколько операций и выполнять их как единое целое. Если какое-либо из утверждений в транзакции завершается неудачей, вся транзакция отменяется, и база данных возвращается в прежнее состояние.

С другой стороны, batch (пакет) – это набор операторов SQL, которые передаются в базу данных для выполнения в виде группы. В отличие от транзакций, пакеты не обеспечивают такого же уровня атомарности или гарантии согласованности. Каждый оператор в пакете выполняется отдельно, и любые ошибки или исключения обрабатываются независимо. Пакеты обычно используются для таких задач, как загрузка данных в базу данных, запуск отчетов или выполнение рутинных задач обслуживания.
### В чем разница между скалярной и табличной функцией?

В SQL функция – это набор инструкций, которые могут быть использованы для выполнения определенной задачи. Существует два типа функций: скалярные и табличные.

Скалярная функция возвращает одно значение и используется в запросе для преобразования входных значений в выходные. Например, скалярная функция может использоваться для выполнения математических операций, таких как нахождение квадратного корня из числа, или для работы со строками, например преобразования их в верхний или нижний регистр.

Табличная функция, с другой стороны, возвращает таблицу в качестве своего набора результатов. Это означает, что функция с табличным значением может использоваться в запросе так же, как и таблица, позволяя объединять, фильтровать и агрегировать данные, которые она возвращает. Табличные функции полезны при сложных манипуляциях с данными, когда набор результатов не известен заранее или когда вы хотите повторно использовать запрос как таблицу.

Одно из ключевых различий между скалярными и табличными функциями заключается в том, что скалярные функции можно вызывать внутри запроса, то есть использовать их как часть предложений SELECT, WHERE или ORDER BY. Табличные функции должны вызываться как часть предложения FROM, поскольку они возвращают таблицу.

Еще одно отличие заключается в том, что скалярные функции возвращают одно значение для каждой строки, в то время как табличные функции могут возвращать несколько строк. Скалярные функции обычно проще и быстрее табличных, но они менее гибкие и не могут использоваться во многих ситуациях.

В общем, скалярные функции возвращают одно значение и используются для преобразования входных значений, а табличные возвращают таблицу и используются для манипулирования данными и их агрегирования.
### Какие ограничения вы знаете, как они работают и указываются?

SQL-ограничения (constraints) указываются при создании или изменении таблицы. Это правила для ограничения типа данных, которые могут храниться в таблице. Действие с данными не будет выполнено, если нарушаются установленные ограничения.

- `UNIQUE` — гарантирует уникальность значений в столбце;
- `NOT NULL` — значение не может быть `NULL`;
- `INDEX` — создаёт индексы в таблице для быстрого поиска/запросов;
- `CHECK` — значения столбца должны соответствовать заданным условиям;
- `DEFAULT` — предоставляет столбцу значения по умолчанию
### Для чего используется ключевое слово ORDER BY?

Для сортировки данных в порядке возрастания (`ASC`) или убывания (`DESC`).
### Назовите четыре основных типа соединения в SQL

Чтобы объединить две таблицы в одну, следует использовать оператор `JOIN`. Соединение таблиц может быть внутренним (`INNER`) или внешним (`OUTER`), причём внешнее соединение может быть левым (`LEFT`), правым (`RIGHT`) или полным (`FULL`).

- `INNER JOIN` — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.
- `FULL OUTER JOIN` — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение `NULL`.
- `LEFT JOIN` — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.
- `RIGHT JOIN` — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.
### А что такое Self JOIN?

Такой вопрос тоже может прозвучать на собеседовании по SQL. Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные таблицы. Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.
### Для чего нужен оператор UNION?

Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в том же порядке.
### Как работают подстановочные знаки?

Это специальные символы, которые нужны для замены каких-либо знаков в запросе. Они используются вместе с оператором `LIKE`, с помощью которого можно отфильтровать запрашиваемые данные.

### Какими бывают подстановочные знаки?

- `%` — заменить ноль или более символов;
- `_` — заменить один символ.
### Что делают псевдонимы Aliases?

SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу. Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами. В этом случае для удобства в составлении запроса используются псевдонимы. SQL-псевдоним существует только на время запроса.
### Для чего нужен оператор INSERT INTO SELECT?

Данный оператор копирует данные из одной таблицы и вставляет их в другую, при этом типы данных в обеих таблицах должны соответствовать.
### Что такое нормализация и денормализация?

Нормализация отношений в SQL призвана [организовать информацию в базе данных](https://tproger.ru/translations/db-scheme-design-guide) таким образом, чтобы она не занимала много места и с ней было удобно работать. Это удаление избыточных данных, устранение дублей, идентификация наборов связанных данных через `PRIMARY KEY`, etc.Соответственно, денормализация является обратным процессом, который вносит в нормализованную таблицу избыточные данные.
### Чем VARCHAR отличается от NVARCHAR?

Главное отличие в том, что `VARCHAR` хранит значения в формате ASCII, где символ занимает один байт, а `NVARCHAR` хранит значения в формате Unicode, где символ «весит» 2 байта. Тип `VARCHAR` следует использовать, если вы уверены, что в значениях не будет Unicode-символов. Например, `VARCHAR` можно применить к адресам электронной почты, состоящих из ASCII-символов.
### Что такое соединения в SQL?

Соединение — это операция, которая используется для объединения данных из нескольких таблиц в новую таблицу. Различные типы объединений определяют, как данные между таблицами сопоставляются с новой таблицей. Когда вам нужно получить данные из нескольких таблиц в одном запросе, есть большая вероятность, что вы будете использовать операцию соединения.

Интервьюеры задают этот вопрос, чтобы проверить ваше фундаментальное понимание того, как запрашиваются данные и насколько это необходимо практически для любого типа приложений. Мы не можем просто свалить все данные в одну таблицу, так как она станет громоздкой и плохо организованной.

Пример: мы хотели бы хранить таблицу клиентов (с их именем, адресом, компанией, которую они представляют и т. д.) отдельно от таблицы транзакций (с купленными товарами, когда была совершена транзакция, сколько стоили товары, кто совершил покупка и др.).

Когда мы сохраняем информацию о том, кто совершил покупку, мы не хотели бы дублировать всю информацию о покупателе в каждой строке таблицы транзакций, и мы хотели бы сохранить только идентификатор клиента. Чтобы ответить на такой вопрос, как «сколько покупок было совершено клиентами, проживающими в определенном почтовом индексе?», нам нужно соединить две таблицы, чтобы получить такой ответ
### Какие существуют способы оптимизации запроса?

Планы запросов — это полезный способ изучить, как будет выполняться запрос, и помочь вам лучше понять, что замедляет выполнение вашего запроса.

Например, добавление к запросу в PostgreSQL символа EXPLAIN покажет план запроса для команды. Это покажет сканирование таблицы, которое будет задействовано в запросе.

Итак, если мы хотим проверить поведение запроса: SELECT * FROM table_1;, we can run the query EXPLAIN SELECT * FROM table_1;. Оттуда план запроса разбивает различные шаги, которые будут предприняты для выполнения запроса. Это распространенный способ выявления ненужных полных сканирований таблицы, который можно облегчить, настроив правильные индексы.

Эти методы важны, потому что интервьюеры хотят понять, как вы можете подходить к устранению неполадок запросов к базе данных. Если кандидат знает только, как выполнить запрос к базе данных для измерения производительности, это свидетельствует о недостатке знаний и опыта работы с реляционными базами данных.
### Какими способами можно определить, как можно оптимизировать запрос?

Запросы можно оптимизировать разными способами. Вот несколько распространенных примеров:

- Уменьшите объем данных для запроса с помощью WHERE предложений.
- Ограничьте количество полезных строк, которые база данных должна запрашивать с помощью LIMIT предложения.
- Добавьте индекс для часто запрашиваемых столбцов.

Цель этого вопроса часто состоит не в том, чтобы просто перечислить все приведенные выше примеры. Поскольку этот вопрос является открытым, некоторые интервьюеры могут представить этот вопрос со сценарием, в котором можно определить и применить определенные оптимизации.
### Что такое нормализация и в чем ее преимущества?

Нормализация базы данных — это стратегия эффективной организации данных в базе данных. Цель состоит в том, чтобы уменьшить количество избыточных данных, чтобы одни и те же данные не хранились в нескольких таблицах. Вместо этого на данные будет ссылаться первичный ключ.

Например, таблица с именем _orders_ может иметь столбец с именем _user_id_ . Вместо того, чтобы хранить копию пользовательских данных в таблице заказов, мы можем просто ссылаться на эти данные из другой таблицы с помощью соединения.

Его часто просят оценить понимание кандидатом дизайна таблицы. Нормализация данных является ключевым компонентом проектирования схем таблиц в реляционных базах данных.

### Что такое сущности и отношения?

Объект представляет собой абстракцию набора связанных данных и представлен в виде таблиц _. Отношения_ определяют, как объекты связаны друг с другом.

Например, предположим, что у нас есть две таблицы с именами orders и users. Наши orders и users являются нашими сущностями. Мы можем представить, что у одного пользователя может быть много заказов. Таким образом, пользователи могут иметь отношения «один ко многим» с заказами.

Сущности и отношения часто используются в процессе разработки схемы таблицы. Понимая, как определять объекты и отображать их отношения, вы показываете, что можете продуктивно работать в коллективном сеансе проектирования таблиц базы данных.

### Как можно настроить таблицу так, чтобы запросы к определенным строкам не приводили к полному сканированию таблицы?

Полного сканирования таблицы можно избежать, запрашивая индексированные столбцы и используя ограничения. Индексированные столбцы помогают базе данных оптимизировать поиск в таблицах.

Существует множество стратегий сокращения запрашиваемых строк, и их можно подтвердить с помощью планов запросов. Интервьюеры часто задают этот вопрос о SQL, чтобы оценить ваше понимание того, как правильно проектировать таблицы SQL и оптимизировать запросы.
### Объясните некоторые различные типы индексов в SQL.

В кластеризованном индексе данные физически хранятся в одной и той же области таблицы, поэтому их можно эффективно запрашивать и извлекать вместе. Некластеризованный индекс часто используется для запросов на основе ключей, тогда как кластеризованный индекс часто используется для диапазонов.

Большинство баз данных SQL выберут лучший тип индекса для вашего варианта использования. Интервьюеры обычно задают этот вопрос, чтобы оценить ваше понимание внутренней настройки индексов.

### Каков сценарий, когда вы решите использовать ноль или пробел над NULL значением в строке?

Использование нуля или пробела над NULL значением является конструктивным решением. NULL может означать отсутствие данных.

Пример можно привести с отчеством: если пользователь не указал отчество, то его отчество будет NULL. Если пользователь указал, что у него нет отчества, то его отчество будет пустой строкой.

Если мы знаем, что никогда не будем заботиться о различии между значением нуля/пробела и отсутствием значения, тогда мы можем пойти дальше и по умолчанию установить для столбца нулевое значение или значение пробела. Это может быть полезно в таблице, которая отслеживает, сколько раз что-то произошло (например, количество посещений веб-сайта). Нам не нужно различать 0 и отсутствие данных, поскольку отсутствие данных подразумевает 0, поэтому мы можем упростить код нашего приложения, установив по умолчанию 0.

Технический рекрутер или менеджер по найму может задать подобный вопрос на собеседовании по SQL, чтобы оценить ваше понимание того, как различные типы хранятся в таблице базы данных. Возможность сообщить об этих решениях показывает, что вы понимаете некоторые соображения по выбору подходящих компромиссов в дизайне.

### В чем разница между перекрестным соединением и естественным соединением?

Если не указано, соединение по умолчанию будет использовать внутреннее соединение. Хотя есть вероятность, что вы раньше не использовали перекрестное соединение или естественное соединение, понимание различных типов соединений может показать интервьюеру, что вы знакомы с различными способами объединения данных между таблицами.

Перекрестное соединение будет производить декартово произведение между двумя таблицами. Обычно он используется, когда вы хотите создать комбинацию, используя каждую строку из двух таблиц. Например, если вы хотите найти все комбинации цветов между различными предметами одежды, вы должны использовать перекрестное соединение для получения каждой комбинации.

Естественное соединение создаст таблицу, которая объединяет столбцы с одинаковыми именами и типами. Любой общий столбец между таблицами будет рассматриваться для объединения. Это отличается от обычно используемого внутреннего соединения, где соединения явно выполняются для указанных столбцов. Важно отметить, что если естественное соединение не находит совпадающих столбцов, оно по существу дает тот же результат, что и перекрестное соединение.

### Что такое UNION, MINUSи INTERSECT команды?

Эти три команды известны как операции над множествами. Интервьюеры зададут вам этот вопрос, чтобы оценить ваше знакомство с анализом данных и обработкой данных с использованием SQL. Если вы широко использовали SQL, но не сталкивались с этими командами, интервьюер может узнать, что вы можете использовать команды SQL для выполнения операций CRUD вместо анализа данных.

- UNION создаст таблицу, в которой данные содержатся в двух таблицах.
- MINUS создаст таблицу, в которой есть данные из первой таблицы за вычетом данных из второй таблицы.
- INTERSECT создаст таблицу с общими данными между двумя таблицами.

Если мы представим диаграмму Венна с двумя пересекающимися окружностями и тремя отдельными частями, UNION представляющими все три части, MINUS представляющими левую часть и INTERSECT
представляющую среднюю часть.
### Зачем нужны групповые функции в SQL?

Групповые функции — один из ключевых способов выполнения анализа данных с помощью SQL. Интервьюер задаст этот вопрос, чтобы определить, используете ли вы SQL для CRUD или использовали ли вы SQL для анализа данных.

Групповые функции помогают нам объединить набор строк в одну группу данных, представленных строками. Эти функции часто используются для анализа таблиц, чтобы лучше понять данные, которые они представляют.

Например, предположим, что у нас есть таблица users , в которой есть строка с именем country , указывающая страну, из которой находится пользователь. Используя GROUP BY, мы можем определить количество пользователей для каждой страны в нашей таблице.

Отвечая на этот вопрос интервью для SQL, также важно предоставить конкретные примеры того, как вы, возможно, использовали групповые функции раньше в прошлом.

### Для чего используются функции SQL?

Функции SQL предоставляют способы выполнения вычислений в базе данных. Они могут включать агрегации, которые часто используются для аналитики. Примером функции агрегирования может быть AVG функция, которая возвращает средние цены, уплаченные за покупку: SELECT AVG(price) AS average_price FROM purchases.

Когда вам зададут этот вопрос, интервьюер будет впечатлен, если вы сможете привести несколько примеров функций SQL, которые вы использовали, и как они использовались в вашем запросе.

### В чем разница между HAVING оговоркой и WHERE оговоркой?

WHERE используется для фильтрации строк перед их возможной группировкой. HAVING используется для фильтрации строк после их группировки. HAVING функции очень похожи на , WHERE но используются после некоторой формы агрегации. WHERE Предложения должны быть предпочтительными, когда это возможно, так как наш запрос будет быстрее, если мы отфильтруем предварительную агрегацию данных, чем последующую, но некоторые фильтры могут выполняться только после агрегации и поэтому требуют использования предложения WHERE .

**Пример** . Учитывая таблицу заказов, верните число customer id и количество заказов, сделанных среди клиентов, совершивших не менее 10 покупок. Единственный способ узнать, сколько заказов сделал клиент, — это сначала подсчитать (объединить) все его заказы перед фильтрацией. Мы могли бы написать этот запрос как SELECT customer_id FROM (SELECT COUNT(*) AS count, customer_id from orders GROUP BY 2) WHERE COUNT >= 10, или мы можем упростить его с помощью HAVING предложения: SELECT COUNT(*) AS count, customer_id from orders GROUP BY 2 HAVING count >= 10

Интервьюер может не спрашивать вас явно о разнице между этими двумя пунктами, но представить вопрос в более широком контексте. Они могут попросить вас написать запрос, в котором для возврата правильного результата необходимы оба предложения WHERE и .HAVING

### Как вы можете получить альтернативные записи из таблицы?

Есть несколько способов получить чередующиеся записи. Цель интервьюера — оценить ваше знакомство и удобство при написании SQL-запросов и использовании функций.

Обычно таблицы имеют автоматически увеличивающиеся первичные ключи. Мы можем использовать оператор модуля % для получения чередующихся строк. Это работает, потому что число, деленное на 2, всегда возвращает либо 0, либо 1.

SELECT * FROM <table_name> WHERE <table_id> % 2 = 0;

SELECT * FROM <table_name> WHERE <table_id> % 2 = 1;

### Назовите оператор, который используется в запросе на сопоставление с образцом.

LIKE используется для сопоставления строк. Различные формы LIKE операций могут быть доступны в разных реализациях базы данных SQL. Например, LIKE часто может использоваться для сопоставления с образцом без учета регистра.

Если у нас есть таблица products с именем столбца с именем name, мы можем искать в каждой строке продукты с именами, содержащими слово _toy_ : SELECT * FROM products WHERE name LIKE '%toy%.

Сопоставление с образцом часто используется для поиска определенного текста в столбце по многим строкам. Интервьюеры будут рады узнать, что вы понимаете, как работает сопоставление с образцом и как оно часто применяется в производственных базах данных.

### Когда было бы более уместно использовать материализованное представление вместо представления?

Как материализованные представления, так и представления упрощают запрос данных, преобразуя некоторые табличные данные в собственную структуру. Материализованные представления сохраняют данные, тогда как представления вычисляют свои данные при каждом запросе.

Это означает, что материализованные представления имеют лучшую производительность чтения, поскольку данные сохраняются. Когда производительности достаточно, иногда рекомендуется использовать представление, чтобы уменьшить объем данных, которые будут храниться с материализованным представлением.

Когда менеджеры по найму и технические рекрутеры задают подобные вопросы на собеседовании по SQL, они заинтересованы в том, чтобы знать, что вы понимаете, как добиться компромиссов в производительности в SQL. Даже если интервьюер не задает именно этот вопрос, вы можете сослаться на преимущества материализованного представления или представления в ситуации, когда вам нужно создавать сложные запросы.

### Перечислите некоторые преимущества и недостатки хранимой процедуры.

Хранимые процедуры полезны для многократно используемых SQL-запросов. На практике мы можем создать хранимую процедуру вместо хранения списка многократно используемых SQL-запросов. Это уменьшает возможность ошибки и стандартизирует набор операций для воспроизводимости.

Однако хранимые процедуры часто очень специфичны для случая использования и не переносимы. Хранимая процедура не будет работать в другой таблице базы данных с аналогичной структурой, и ее необходимо будет создать заново, чтобы она заработала.

Поскольку они являются пользовательскими, их сложно тестировать и интегрировать с другими инструментами. Разработчики часто используют инструменты, расположенные поверх баз данных, чтобы упростить разработку приложений — известно, что хранимые процедуры несовместимы с некоторыми из этих инструментов.

Чтобы сделать ваш ответ на этот вопрос интервью SQL более эффективным, сошлитесь на пример, когда вы, возможно, использовали или рассматривали возможность использования хранимой процедуры. Интервьюеры, как правило, больше впечатляются, когда ответ кандидата подкрепляется соответствующим опытом, а не определениями.

### В чем разница между базами данных OLTP (например, MySQL) и OLAP (например, хранилище данных)?

Это еще один из тех вопросов для собеседования с разработчиками SQL, которые призваны помочь интервьюеру оценить, понимает ли кандидат различные базы данных SQL, которые могут существовать, и чем они отличаются друг от друга. Различные варианты использования часто определяют тип используемой базы данных SQL.

Базы данных OLTP предназначены для быстрых запросов с надежной целостностью данных. Как правило, они оптимизированы для выполнения повседневных бизнес-операций, связанных с чтением и записью в реальном времени.

Базы данных OLAP оптимизированы для автономной аналитики и обычно включают сложные агрегаты. По сравнению с базами данных OLTP они часто имеют меньшие объемы запросов, содержат больше исторических данных и требуют значительно меньшего количества правок.

Если мы проиллюстрируем это на веб-приложении, база данных OLTP, вероятно, обрабатывает метаданные для веб-приложения. Действия пользователя и данные сохраняются и извлекаются для базы данных OLTP. Базы данных OLAP, вероятно, будут хранить данные того же типа, но будут использоваться для понимания ключевых показателей, таких как удержание пользователей и их поведение.

Ваш ответ на этот вопрос SQL будет гораздо более эффективным, если вы предоставите примеры различных баз данных OLTP и баз данных OLAP, которые вы, возможно, использовали.
### Дайте определение DDL и DML.

Управление свойствами и атрибутами базы данных называется языком определения данных (DDL).

Манипулирование данными в базе данных, например вставка, обновление и удаление, определяется как язык манипулирования данными. (ДМЛ)
### Что вы подразумеваете под охотой за индексами?

Индексы помогают повысить скорость и производительность запросов к базе данных. Процедура увеличения коллекции индексов называется охотой за индексами.
### Как поиск индекса помогает повысить производительность запросов?

Поиск индекса помогает повысить скорость, а также производительность запросов к базе данных. Для этого применяются следующие меры:

- Оптимизатор запросов используется для координации изучения запросов с рабочей нагрузкой и наилучшего использования предлагаемых на основе этого запросов.
- Индекс, распределение запросов и их производительность наблюдаются для проверки эффекта.
- Также рекомендуется настроить базы данных на небольшой набор проблемных запросов.
### Перечислите недостатки запроса.

Недостатки запроса:

- Нет индексов
- Хранимые процедуры чрезмерно компилируются.
- Триггеры и процедуры без SET NOCOUNT ON.
- Сложные соединения, составляющие неадекватно написанный запрос.
- Курсоры и временные таблицы демонстрируют плохое представление.
### Найдите способы эффективного кодирования транзакций.

Способы эффективного кодирования транзакций:

- Пользовательский ввод не должен быть разрешен во время транзакций.
- Во время просмотра транзакции не должны открываться с данными.
- Транзакции должны быть как можно меньшими.
- Более низкий уровень сегрегации транзакций.
- Во время транзакции должен быть доступен минимум информации о данных.
### Что такое исполнительный план?

Исполнительный план можно определить как:

- SQL Server кэширует собранную процедуру или план выполнения запроса и затем использует их при последующих вызовах.
- Важная особенность, связанная с повышением производительности.
- План выполнения данных можно просмотреть в текстовом или графическом виде.
### Дайте определение B-деревьям.

Структура данных в виде дерева, в которой хранятся отсортированные данные, а поиск, вставка, последовательный доступ и удаление разрешены за логарифмическое время.
### Отличайте сканирование таблицы от сканирования индекса.

Перебор всех строк таблицы называется сканированием таблицы, а перебор всех элементов индекса определяется как сканирование индекса.
### Что вы подразумеваете под понятием коэффициента заполнения применительно к индексам?

Коэффициент заполнения можно определить как значение, которое определяет процент оставшегося пространства на каждой конечной странице, которая должна быть заполнена данными. 100 — значение коэффициента заполнения по умолчанию.
### Дайте определение фрагментации.

Фрагментацию можно определить как особенность базы данных сервера, которая promotes контролирует данные, которые пользователь хранит на уровне таблицы.
### Что такое секционирование базы данных?

Разделение логической базы данных на независимые целостные единицы для улучшения ее управления, доступности и производительности называется секционированием базы данных.
### Объясните важность разделения.

Разделение одной большой таблицы на более мелкие объекты базы данных логически называется секционированием базы данных. Его преимущества:

- Для значительного повышения производительности запросов в ситуациях, когда в одном разделе находятся в основном строки, к которым часто обращаются.
- Доступ к большим частям одного раздела
- Для данных, которые редко используются, можно использовать более медленные и дешевые носители.
###  Определить Atomлед и агрегация.

**Atomлед:** Это концепция «все или ничего», которая позволяет пользователю быть уверенным в том, что о незавершенных транзакциях придется позаботиться. Действия, связанные с незавершенными транзакциями, в СУБД остаются невыполненными.

**Агрегация:** Собранные сущности и их отношения агрегируются в этой модели. В основном он используется для выражения отношений внутри отношений.
### Дайте определение объектно-ориентированной модели.

Компиляции объектов составляют эту модель, в которой значения хранятся в переменных экземпляра, находящихся внутри объекта. Сам объект включает в себя тела объекта для своего operaкоторые называются методами. Объекты, содержащие одинаковые переменные и методы, называются классами.
## Как найти зарплату сотрудника, которая является n-й по величине в таблице

Чтобы найти n-ю по величине зарплату, можно использовать конструкцию `LIMIT` и упорядочить зарплаты в порядке убывания.
## Объясните разницу между UNION и UNION ALL

Оператор `UNION` используется для объединения результатов двух или более операторов `SELECT` и удаляет дублирующиеся строки. С другой стороны, `UNION ALL` объединяет наборы результатов без удаления дубликатов. Поскольку `UNION ALL` не осуществляет дополнительный шаг по удалению дубликатов, он обычно быстрее. Однако если необходимо удалить дубликаты, то следует использовать `UNION`.
## Объясните концепцию подзапросов в SQL

Подзапрос SQL — это запрос, вложенный в другой запрос. Он может использоваться внутри операторов `WHERE`, `FROM` или `HAVING`. Результат подзапроса используется в качестве условия или источника данных для внешнего запроса (оператора, который содержит подзапрос). Подзапросы полезны для выполнения сложных запросов или доступа к данным из нескольких таблиц.
## Как найти второе по величине значение в столбце

Для этого можно использовать комбинацию операторов `ORDER BY` и `LIMIT`
## Объясните функцию COALESCE в SQL

Функция `COALESCE` используется для возврата первого значения, отличного от null, из списка выражений. Она принимает несколько аргументов и возвращает первое значение, содержащее какие-либо данные. Если все значения равны null, то возвращается null. `COALESCE` особенно полезна при работе со столбцами, в которых могут отсутствовать данные.
## Как найти наиболее часто встречающееся значение в столбце

Чтобы найти наиболее часто встречающееся значение в столбце, можно использовать операторы `GROUP BY`, `COUNT` и `ORDER BY`.
## Для чего используется оператор CASE в SQL

Оператор `CASE` нужен для выполнения условной логики в SQL-запросах. Он позволяет определить различные результаты на основе заданных условий. Существует два формата оператора `CASE` — простой и поисковой.
## Как найти дублирующиеся строки в таблице

Для поиска дублирующихся строк в таблице можно использовать операторы `GROUP BY` и `HAVING` вместе с агрегатной функцией `COUNT`
## Как вычислить среднее значение с помощью SQL

Чтобы вычислить среднее значение по столбцу, можно использовать функцию `AVG`. Она принимает столбец в качестве входных данных и возвращает среднее значение.
## Для чего используется оператор GROUP BY

Оператор `GROUP BY` нужен для группировки строк на основе одного или нескольких столбцов. Он часто используется с агрегатными функциями, такими как `COUNT`, `SUM`, `AVG` и т. д. При использовании `GROUP BY` результат разделяется на группы, основанные на указанном столбце, и к каждой группе применяются агрегатные функции.
## Как получить текущую дату и время в SQL

Большинство систем баз данных предоставляют функции для получения текущей даты и времени. Вот несколько примеров:

- MySQL: `SELECT CURDATE(), CURTIME();`
- PostgreSQL: `SELECT CURRENT_DATE, CURRENT_TIME;`
- SQL Server: `SELECT GETDATE();`
- Oracle: `SELECT SYSDATE FROM DUAL;`

Эти функции возвращают текущую дату и время согласно внутреннему времени системы баз данных.
## Объясните разницу между представлением и таблицей

Таблица — это основная структура в базе данных, которая хранит данные в строках и столбцах. Она используется для организации и хранения данных в табличном формате.

Представление — это виртуальная таблица, полученная из одной или нескольких таблиц. Она не хранит данные, но определяется запросом. Представления позволяют упростить сложные запросы, скрыть конфиденциальную информацию и представить подмножество данных пользователям, не давая им прямого доступа к основным таблицам.
## Как удалить дублирующиеся строки из таблицы

Для этого можно использовать оператор `DELETE` с подзапросом, который идентифицирует дублирующиеся строки.
## Как узнать длину строки с помощью SQL

Метод определения длины строки зависит от системы баз данных. Вот несколько примеров:

- MySQL: `SELECT LENGTH(string);`
- PostgreSQL: `SELECT LENGTH(string);`
- SQL Server: `SELECT LEN(string);`
- Oracle: `SELECT LENGTH(string) FROM DUAL;`

В этих примерах функции `LENGTH` или `LEN` возвращают количество символов в заданной строке.
## Объясните концепцию свойств ACID в транзакциях базы данных

ACID расшифровывается как атомарность, согласованность, изоляция и устойчивость. Эти свойства обеспечивают надёжность, целостность и последовательность транзакций баз данных.

- **Атомарность**. Транзакция рассматривается как единое целое и либо выполняется полностью, либо не завершается вообще. Если какая-либо часть транзакции выполняется неудачно, вся транзакция отменяется, оставляя базу данных в исходном состоянии.
- **Согласованность**. Транзакция переводит базу данных из одного согласованного состояния в другое. Это гарантирует, что ограничения целостности данных не будут нарушены во время транзакции.
- **Изоляция**. Транзакции выполняются отдельно друг от друга. Изменения, внесённые одной транзакцией, не видны другим транзакциям до тех пор, пока они не будут зафиксированы.
- **Устойчивость**. Как только транзакция зафиксирована, её изменения становятся постоянными и сохраняются после любых дальнейших сбоев, таких как сбои питания или системы.
## Как можно объединить строки в SQL

Для этого можно использовать оператор конкатенации строк, который зависит от системы баз данных:

- MySQL: `SELECT CONCAT(string1, string2);`
- PostgreSQL: `SELECT string1 || string2;`
- SQL Server: `SELECT string1 + string2;`
- Oracle: `SELECT string1 || string2 FROM DUAL;`

В этих примерах оператор или функция объединяет указанные строки в одну конкатенированную строку.
## Для чего используется оператор ROLLBACK

Оператор `ROLLBACK` применяется для отмены изменений, внесённых в транзакцию, и восстановления базы данных в состояние до начала транзакции. Обычно он используется при возникновении ошибки или когда транзакцию необходимо отменить.
## Как узнать разницу между двумя датами в SQL

Чтобы найти разницу между двумя датами в SQL, можно использовать функции разности дат, предоставляемые системой базы данных.
## Как можно выполнить пагинацию в SQL

Пагинация используется для ограничения количества строк, возвращаемых запросом, и часто применяется для отображения данных в виде фрагментов. Разные системы баз данных используют разный синтаксис для пагинации.
### **Что такое перекрёстное соединение?**

Во время перекрёстного соединения каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц.
### **Какие существуют виды индексов?**

Индексы бывают нескольких типов:

- Уникальный и неуникальный индекс:

Уникальные индексы - это индексы, которые помогают поддерживать целостность данных, гарантируя, что никакие две строки данных в таблице не имеют идентичных значений.

Неуникальные индексы не используются для применения ограничений к таблицам, с которыми они связаны. Вместо этого, неуникальные индексы используются исключительно для повышения производительности запросов за счет поддержания отсортированного порядка значений данных, которые часто используются.

- Кластеризованные и некластеризованные индексы

Кластеризованные индексы - это индексы, порядок строк в базе данных которых соответствует порядку строк в индексе. Вот почему в данной таблице может существовать только один кластеризованный индекс.

Некластеризованные индексы имеют структуру, отдельную от строк данных. В некластеризованном индексе содержатся значения ключа некластеризованного индекса, и каждая запись значения ключа содержит указатель на строку данных, содержащую значение ключа.
### **В чём разница между кластеризованными и некластеризованными индексами?**

Основное различие между кластеризованным и некластеризованным индексом состоит в том, что кластеризованный индекс определяет, как данные хранятся в строках таблицы. С другой стороны, некластеризованный индекс хранит данные в одном месте, а индексы хранятся в другом месте.
### **Что такое целостность данных?**

Целостность данных-это поддержание и обеспечение точности и согласованности данных на протяжении всего их жизненного цикла. Является критическим аспектом проектирования, внедрения и использования любой системы, которая хранит, обрабатывает или извлекает данные.
### **Что такое курсор?**

Курсор в SQL – это область в памяти базы данных, которая предназначена для хранения последнего оператора SQL. Если текущий оператор – запрос к базе данных, в памяти сохраняется и строка данных запроса, называемая текущим значением, или текущей строкой курсора.
### **Перечислите различные типы связей в SQL.**

- One-to-One - этот тип может быть определён как отношение между двумя таблицами, где каждая запись в одной таблице связана максимум с одной записью в другой таблице.
- One-to-Many & Many-to-One - это наиболее часто используемое отношение, когда запись в таблице связана с несколькими записями в другой таблице.
- Many-to-Many - этот тип используется в случаях, когда для определения отношения требуется несколько экземпляров с обеих сторон.
- Self-Referencing Relationships - этот тип используется, когда таблице необходимо определить связь с самой собой.
### **Зачем нужны операторы TRUNCATE, DELETE и DROP?**

TRUNCATE удаляет все строки из таблицы.

Команда DELETE используется для удаления одной или всех строк в таблице.

Команда DROP удаляет таблицу из базы данных. Все строки таблицы, индексы и привилегии удаляются.
### **В чём разница между операторами DROP и TRUNCATE?**

Команда DROP удаляет таблицу из базы данных целиком, вместе со структурой. То есть после выполнения такой команды обратиться к удаленной таблице, например с помощью SELECT, будет уже нельзя. В свою очередь команда TRUNCATE удаляет не саму таблицу, а данные, которые эта таблица содержит.
### **Что такое агрегатные и скалярные функции?**

Агрегатная функция выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение. Для сравнения — скалярные функции принимают на вход одно значение и возвращают одно значение.

Примеры агрегатных функций:

- AVG() - Функция вычисляет среднее значение
- MAX() - Функция вычисляет элемент с максимальным значением
- MIN() - Функция вычисляет элемент с минимальным значением
- SUM() - Функция суммирует значения

Примеры скалярных функций:

- LEN() - Функция вычисляет общую длину поля
- MID() - Функция извлекает подстроки из набора строковых значений в таблице
- RAND() - Функция генерирует случайный набор чисел заданной длины
- NOW() - Функция возвращает текущую дату и время
### **В чём различия между OLTP и OLAP?**

OLTP-это система обработки транзакций, то есть она управляет приложениями, основанными на транзакциях, через Интернет. Например, системы OLTP отвечают за предоставление данных в хранилища данных. С другой стороны, OLAP-это система аналитической обработки. Это означает, что она отвечает на многомерные аналитические запросы, соответствующие финансовой отчетности, прогнозированию и т.д. Например, данные, доступные в хранилище данных, анализируются с помощью OLAP-системы.
### **Что такое секционирование таблицы в PostgreSQL?**

Секционированием данных называется разбиение одной большой логической таблицы на несколько меньших физических секций.
### **Что такое токен в PostgreSQL?**

Токеном в PostgreSQL может являться ключевое слово, идентификатор, литерал, константа, идентификатор в кавычках, либо любой символ, обладающий отличительной индивидуальностью. Они могут быть разделены пробелом, новой строкой или табуляцией. Если токены являются ключевыми словами, то обычно это команды с полезными значениями. Токены известны как строительные блоки любого кода PostgreSQL
### **Какова максимальная ёмкость таблицы в PostgreSQL?**

Максимальный размер таблицы PostgreSQL может составлять 32 ТБ.
### **Можете ли вы объяснить архитектуру PostgreSQL?**

Архитектура PostgreSQL соответствует модели клиент-сервер.

Серверная часть состоит из диспетчера фоновых процессов, обработчика запросов, утилит и общего пространства памяти, которые работают вместе для создания экземпляра PostgreSQL, имеющего доступ к данным. Клиентское приложение выполняет задачу подключения к этому экземпляру и запрашивает обработку данных у служб. Клиентом может быть либо GUI (графический пользовательский интерфейс), либо веб-приложение. Наиболее часто используемым клиентом для PostgreSQL является pgAdmin
### **Что вы понимаете под управлением параллелизмом нескольких версий?**

Под управлением параллелизмом подразумевают различные техники, которые используются для сохранения целостности базы данных, когда несколько пользователей обновляют строки одновременно. Неверный параллелизм может привести к проблемам, таким как чтение фантомных данных, чтение недействительных данных и неповторяемые чтения.
### **Поддерживает ли PostgreSQL полнотекстовый поиск?**

Полнотекстовый поиск - это метод поиска одного документа или коллекции документов, хранящихся на компьютере, в полнотекстовой базе данных. В основном он поддерживается в продвинутых системах баз данных, таких как SOLR или ElasticSearch. Тем не менее, эта функция присутствует, но довольно проста в PostgreSQL.
### **Что такое параллельные запросы в PostgreSQL?**

Параллельные запросы в PostgreSQL имеют возможность использовать более одного ядра процессора для каждого запроса.В параллельных запросах оптимизатор разбивает задачи запроса на более мелкие части и распределяет каждую задачу по нескольким ядрам процессора.
### **В чём разница между commit и checkpoint?**

Действие commit обеспечивает сохранение согласованности данных транзакции и завершает текущую транзакцию в разделе. Commit добавляет в журнал новую запись, описывающую фиксацию в памяти. Checkpoint используется для записи всех изменений, которые были зафиксированы на диске, вплоть до SCN, которые будут храниться в заголовках файлов данных и файлах управления.
#### Операторы определения данных (англ. Data Definition Language, DDL)

DDL — это часть SQL, которая служит для определения структуры данных в начальном состоянии, когда база данных только создается. Операторы определения данных используются, главным образом, для создания и реструктуризации объектов базы данных. К этим операторам относятся CREATE, ALTER и DROP.

CREATE служит для создания объектов базы данных, ALTER — для их изменения, DROP — для удаления.

#### Операторы манипуляции данными (англ. Data Manipulation Language, DML)

DML используется для работы с уже существующими данными, содержащимися в базе данных. С помощью этих операторов пользователи могут получать данные из базы и совершать над ними какие-то манипуляции. К этим операторам относятся SELECT, INSERT, UPDATE, DELETE.

Оператор INSERT позволяет вносить данные в базу данных, UPDATE — обновлять их, DELETE — удалять данные из базы.

#### Операторы определения доступа к данным (англ. Data Control Language, DCL)

DCL используется для контроля доступа к данным в базе данных. Команды DCL обычно служат для создания объектов, имеющих отношение к доступу пользователей к базе, а также к распределению разрешений между пользователями. Для этих операций используются операторы GRANT и REVOKE. Первый служит для «выдачи» разрешений, а второй — для их отзыва.

#### Операторы управления транзакциями (англ. Transaction Control Language, TCL)

TCL используется для контроля изменений, осуществленных при помощи DML. Также с помощью TCL происходит объединение операторов в логические транзакции. К операторам управления транзакциями относятся COMMIT, ROLLBACK, SAVEPOINT, BEGIN, TRANSACTION.
### Что такое AUTO_INCREMENT?

AUTO_INCREMENT используется в SQL для автоматической генерации уникального номера при каждом добавлении записи в таблицу.

Поскольку первичный ключ уникален для каждой записи, мы добавляем это поле в качестве AUTO_INCREMENT поля, таким образом при каждой вставке новой записи номер будет увеличиваться автоматически.

По умолчанию значение AUTO-INCREMENT начинается с 1 и увеличивается на 1 при каждом добавлении новой записи.
### Чем отличаются команды DELETE и TRUNCATE?

- DELETE используется для удаления одной или большего числа существующих таблиц.
- TRUNCATE удаляет все данные внутри таблицы.

Между DELETE и TRUNCATE существуют следующие различия:

- TRUNCATE — это команда DDL, а DELETE — команда DML.
- При помощи TRUNCATE мы не можем активировать триггер, а с DELETE можем.
- TRUNCATE не будет работать, если таблица содержит внешние ключи. В этом случае придется использовать DELETE.
## Выполнение транзакций

Можно выполнять транзакции последовательно или параллельно

И если в первом случае все понятно, то со вторым могут возникать "феномены", например:

1. **Потерянное обновление** (_lost update_)

Когда разные транзакции одновременно изменяют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.

2. **«Грязное» чтение** (_dirty read_)

Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.

3. **Неповторяющееся чтение** (_non-repeatable read_)

При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные. В результате тот же самый запрос выдает другой результат.

4. **Фантомное чтение** (_phantom read_).

Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.

5. **Аномалия сериализации** (_serialization anomaly_)

Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одного из возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно.
## Уровни изоляции в SQL

1. _Read Uncommitted_

Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение «грязных» (незафиксированных) данных.

Однако в PostgreSQL требования, предъявляемые к этому уровню, более строгие, чем в стандарте: чтение «грязных» данных на этом уровне не допускается.

2. _Read Committed_

Не допускается чтение «грязных» (незафиксированных) данных. Транзакция может видеть только те незафиксированные изменения данных, которые произведены в ходе выполнения ее самой.

3. _Repeatable Read_

Не допускается чтение «грязных» (незафиксированных) данных и неповторяющееся чтение. В PostgreSQL на этом уровне не допускается также фантомное чтение.

4. _Serializable_

Не допускается ни один из феноменов, перечисленных выше, в том числе и аномалии сериализации.

Конкретный уровень изоляции обеспечивает сама СУБД с помощью своих внутренних механизмов. Его достаточно указать в команде при старте транзакции.

Однако программист может дополнительно использовать некоторые операторы и приемы программирования, например, устанавливать блокировки на уровне отдельных строк или всей таблицы.
## Блокировки

Кроме поддержки уровней изоляции транзакций, многие СУБД позволяют также создавать блокировки данных как на уровне отдельных строк, так и на уровне целых таблиц.

Команда `SELECT` имеет предложение `FOR UPDATE`, которое позволяет заблокировать отдельные строки таблицы с целью их последующего обновления.

Если одна транзакция заблокировала строки с помощью этой команды, тогда параллельные транзакции не смогут заблокировать эти же строки до тех пор, пока первая транзакция не завершится, и тем самым блокировка не будет снята.
### **Как можно создать индексы?**

🔹 Индекс по столбцу (это чистая классика)

🔹 Индекс по нескольким столбцам

🔹 Уникальный индекс

🔹 Индекс на основе выражения

🔹 Частичный индекс
## Планировщик

Это такой встроенный механизм в СУБД, перед выполнением запроса он формирует "план" выполнения запроса. Просмотреть план выполнения любого запроса можно с помощью команды `EXPLAIN`. Для детального понимания планов выполнения сложных запросов требуется опыт.

Планировщиком можно управлять с целью просмотра логики его работы и дальнейшей оптимизации запросов
## Оптимизация запросов

Повлиять на скорость выполнения запроса можно различными способами. Я запомнил их так: изменить сам sql-запрос, обновить статистику планировщика, денормализация и 4 вариации изменения параметров планировщика:

- изменение исходного кода запроса
    
- обновление статистики, на основе которой планировщик строит планы
    
- денормализация: создание временных таблиц или создание индексов
    
- изменение параметров планировщика, управляющих выбором порядка соединения наборов строк
    
- изменение параметров планировщика, управляющих выбором метода доступа к данным (`enable_seqscan`, `enable_indexscan`, `enable_indexonlyscan`, `enable_bitmapscan`)
    
- изменение параметров планировщика, управляющих способом соединения наборов строк (`enable_nestloop`, `enable_hashjoin`, `enable_mergejoin`);
    
- изменение параметров планировщика, управляющих использованием ряда операций: агрегирование на основе хеширования, материализация временных наборов строк, выполнение явной сортировки при наличии других возможностей.
## Какие есть концепции масштабируемости БД

Я всегда выделял 2 основных. Это _Шардирование_ и _Репликация._ В обоих случаях подразумевается наличие нескольких инстансов БД.

Для шардирования мы определяем срезы строк, которые будут храниться в конкретном инстансе, например для первого, это с 1 по 10 000, а для второго с 10 001 по 20 000 и так далее.

Репликация подразумевает создание одного инстанса-контроллера и нескольких инстансов-нод. То есть по сути это полное копирование СУБД на другой сервер. Таким образом контроллер сам будет решать в какую ноду и что ему записывать.

По статистике и, наверное, логике выборки данных `SELECT` в интернетах выполняются во много раз чаще, чем `INSERT`'ы, на этом фоне репликация выглядит привлекательнее.
## Что будет если сделать EXPLAIN ANALYZE DROP DATABASE POSTGRES

Ну и напоследок такой вопрос с подвохом: всё плохо будет, потому что из-за `ANALYZE` субд мало того что с радостью удалит главную бд, так она ещё и посчитает веса а также время выполнения данного действа.

То есть простой `EXPLAIN` показывает план а `EXPLAIN ANALYZE` его ещё и выполняет
### Какие существуют виды нормализации?

[Нормализация базы данных](https://www.guru99.com/ru/database-normalization.html) можно легко понять с помощью тематического исследования. Нормальные формы можно разделить на 6 форм, они описаны ниже.

![Нормальные формы базы данных](https://www.guru99.com/images/NormalizationProcess(1).png)

Нормальные формы базы данных

- **Первая нормальная форма (1НФ):.**

Это должно удалить все повторяющиеся столбцы из таблицы. Создание таблиц связанных данных и определение уникальных столбцов.

- **Вторая нормальная форма (2NF):.**

Соответствие всем требованиям первой нормальной формы. Размещение подмножеств данных в отдельных таблицах и создание связей между таблицами с использованием первичных ключей.

- **Третья нормальная форма (3НФ):.**

Это должно соответствовать всем требованиям 2NF. Удаление столбцов, которые не зависят от ограничений первичного ключа.

- **Четвертая нормальная форма (4НФ):.**

Если ни один экземпляр таблицы базы данных не содержит два или более независимых и многозначных данных, описывающих соответствующий объект, то он находится в 4th Нормальная форма.

- **Пятая нормальная форма (5НФ):.**

Таблица находится в 5-й нормальной форме только в том случае, если она находится в 4НФ и ее нельзя разложить на любое количество меньших таблиц без потери данных.

- **Шестая нормальная форма (6НФ):.**

Шестая нормальная форма не стандартизирована, однако она уже некоторое время обсуждается экспертами по базам данных. Будем надеяться, что в ближайшем будущем у нас будет четкое и стандартизированное определение 6-й нормальной формы…
### Что такое отношения и какие они бывают?

Отношения с базой данных определяются как связь между таблицами в базе данных. Существуют различные отношения баз данных, и они заключаются в следующем:

- Отношения один к одному.
- Отношения «один ко многим».
- Отношения «многие к одному».
- Самореферентные отношения.
### Что такое запрос?

Запрос к БД — это код, написанный для получения информации из базы данных. Запрос можно спроектировать таким образом, чтобы он соответствовал нашим ожиданиям от набора результатов. Просто вопрос к базе данных.
### Что такое подзапрос?

Подзапрос — это запрос внутри другого запроса. Внешний запрос называется основным запросом, а внутренний запрос называется подзапросом. Подзапрос всегда выполняется первым, а результат подзапроса передается основному запросу.
### Какие бывают типы подзапросов?

Существует два типа подзапросов — коррелированные и некоррелированные.

Коррелированный подзапрос не может рассматриваться как независимый запрос, но он может ссылаться на столбец таблицы, указанный в списке FROM основного запроса.

Некоррелированный подзапрос можно рассматривать как независимый запрос, а выходные данные подзапроса подставляются в основной запрос.
### Что такое хранимая процедура?

Сохраненная процедура — это функция, состоящая из множества операторов SQL для доступа к системе базы данных. Несколько операторов SQL объединяются в хранимую процедуру и выполняются в любое время и в любом месте.
### Что такое триггер?

Триггер БД — это код или программы, которые автоматически выполняются в ответ на какое-либо событие в таблице или представлении в базе данных. В основном триггер помогает поддерживать целостность базы данных.

Пример: Когда в базу данных студентов добавляется новый студент, новые записи должны быть созданы в связанных таблицах, таких как таблицы экзаменов, оценок и посещаемости.
### Что такое локальные и глобальные переменные и их различия?

Локальные переменные — это переменные, которые могут использоваться или существовать внутри функции. Они неизвестны другим функциям, и на эти переменные нельзя ссылаться или использовать. Переменные могут создаваться при каждом вызове этой функции.

Глобальные переменные — это переменные, которые могут использоваться или существовать во всей программе. Та же переменная, объявленная в global, не может использоваться в функциях. Глобальные переменные не могут быть созданы при каждом вызове этой функции.
### Что такое ограничение?

Ограничение можно использовать для указания ограничения на тип данных таблицы. Ограничение можно указать при создании или изменении оператора таблицы. Пример ограничения.

- НЕ НОЛЬ.
- ЧЕК.
- ДЕФОЛТ.
- УНИКАЛЬНЫЙ.
- ОСНОВНОЙ КЛЮЧ.
- ВНЕШНИЙ КЛЮЧ.
### Что такое хранилище данных?

Datawarehouse — это центральное хранилище данных из нескольких источников информации. Эти данные консолидируются, преобразуются и предоставляются для майнинга и онлайн-обработки. Данные хранилища имеют подмножество данных, называемое витринами данных.
### Что такое самостоятельное присоединение?

Самосоединение настроено как запрос, используемый для сравнения с самим собой. Это используется для сравнения значений в столбце с другими значениями в том же столбце в той же таблице. ALIAS ES можно использовать для сравнения одной и той же таблицы.
### Что такое определяемые пользователем функции?

Пользовательские функции — это функции, написанные для использования этой логики всякий раз, когда это необходимо. Не обязательно писать одну и ту же логику несколько раз. Вместо этого функцию можно вызывать или выполнять всякий раз, когда это необходимо.
### Каковы все типы пользовательских функций?

Три типа определяемых пользователем функций.

- Скалярные функции.
- Встроенные табличные функции.
- Многозначные функции.

Скалярная единица возврата, вариант определяет предложение возврата. Другие два типа возвращают таблицу в качестве возврата.
### Что такое сопоставление?

Параметры сортировки определяются как набор правил, которые определяют, как можно сортировать и сравнивать символьные данные. Это можно использовать для сравнения символов A и других языков, а также зависит от ширины символов.

Значение ASCII можно использовать для сравнения этих символьных данных.
### аковы различные типы чувствительности сопоставления?

Фоллоwing различные типы чувствительности сортировки -.

- Чувствительность к регистру – A и a и B и b.
- Чувствительность к акценту.
- Чувствительность к кане – японские иероглифы кана.
- Чувствительность к ширине – однобайтовый символ и double байтовый символ.
### Преимущества и недостатки хранимых процедур?

Хранимая процедура может использоваться как модульное программирование – это означает создание один раз, сохранение и вызов несколько раз, когда это необходимо. Это поддерживает более быстрое выполнение вместо выполнения нескольких запросов. Это снижает сетевой трафик и обеспечивает лучшую безопасность данных.

Недостаток заключается в том, что он может выполняться только в базе данных и использует больше памяти на сервере базы данных.
### Что такое онлайн-обработка транзакций (OLTP)?

Онлайн-обработка транзакций (OLTP) управляет приложениями на основе транзакций, которые можно использовать для ввода, извлечения и обработки данных. OLTP делает управление данными простым и эффективным. В отличие от систем OLAP, целью систем OLTP является обслуживание транзакций в реальном времени.

Пример – банковские операции ежедневно.
### Что такое СТАТЬЯ?

Предложение SQL определено для ограничения набора результатов путем предоставления условия запросу. Обычно это фильтрует некоторые строки из всего набора записей.

Пример. Запрос с условием WHERE.

Запрос с условием HAVING.
### Что такое рекурсивная хранимая процедура?

Хранимая процедура, которая вызывается сама по себе, пока не достигнет некоторого граничного условия. Эта рекурсивная функция или процедура помогает программистам использовать один и тот же набор кода любое количество раз.
### Что такое команды Union, minus и Interact?

СОЮЗ operaTor используется для объединения результатов двух таблиц и удаляет повторяющиеся строки из таблиц.

МИНУС operator используется для возврата строк из первого запроса, но не из второго запроса. Будут отображены совпадающие записи первого и второго запроса, а также другие строки из первого запроса.yed в результате набор.

ПЕРЕСЕЧЕНИЕ operator используется для возврата строк, возвращаемых обоими запросами.
### Что такое агрегатные и скалярные функции?

Агрегатные функции используются для оценки математических вычислений и возврата отдельных значений. Это можно рассчитать по столбцам таблицы. Скалярные функции возвращают одно значение на основе входного значения.

Пример -.

Агрегат – max(), count – рассчитывается относительно числового значения.

Скаляр — UCASE(), NOW() — вычисляется относительно строк.
### Почему мои запросы работают медленно? Почему они не используют мои индексы?

Индексы не используются для каждого запроса. Они используются только если таблица больше минимального размера и запрос выбирает только маленький процент строк в таблице. Так устроено, потому что доступ к диску с применением рандомизации при сканировании индексов может быть медленнее, чем простое чтение таблицы или ее последовательное сканирование.

Чтобы определить необходимость использования индекса для какой-либо таблицы, PostgreSQL должен иметь статистику по этой таблице. Эта статистика собирается при использовании VACUUM ANALYZE или просто ANALYZE. Используя статистику, оптимизатор узнает о том как много строк в таблице и если он должен использовать индексы, то он может принимать лучшие решения. Статистика также влияет на определение оптимального порядка соединений таблиц и метода соединения. При изменении содержимого таблицы должен периодически выполняться сбор статистики.

Обычно индексы не используются для ORDER BY или для выполнения соединений таблиц. Последовательный перебор, следующий за явной сортировкой, обычно быстрее, чем поиск по индексам в большой таблице. Однако, ORDER BY часто комбинируется с LIMIT и в этом случае индекс будет использоваться, поскольку при выполнении будет возвращаться небольшая часть таблицы.

Если вам кажется, что оптимизатор некорректно выбирает последовательный перебор, используйте SET enable_seqscan TO 'off' и запустите запрос снова, чтобы увидеть, действительно ли сканирование индексов быстрее.

Когда используются операции с шаблонами, например LIKE или ~, индексы могут быть использованы в следующих случаях:

- Начало строки поиска должно совпадать с началом искомой строки, т.е.:
    - LIKE шаблоны не должны начинаться с % или _.
    - ~ шаблоны регулярных выражений должна начинаться на ^.

- Строка поиска не должна начинаться с символьного класса, например [a-e].

- Поиск, независимый от регистра, такой как ILIKE и ~* не использует индексы. Вместо него используйте индексы выражений, которые описываются в

[вопросе 6.9](https://wiki.postgresql.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE_%D0%97%D0%B0%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5_%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B#.D0.9A.D0.B0.D0.BA_.D0.BC.D0.BD.D0.B5_.D0.B2.D1.8B.D0.BF.D0.BE.D0.BB.D0.BD.D0.B8.D1.82.D1.8C_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D1.80.D0.B5.D0.B3.D1.83.D0.BB.D1.8F.D1.80.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B2.D1.8B.D1.80.D0.B0.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B8_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D0.BD.D0.B5.D0.B7.D0.B0.D0.B2.D0.B8.D1.81.D0.B8.D0.BC.D1.8B.D0.B9_.D0.BE.D1.82_.D1.80.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D0.B0_.D0.B1.D1.83.D0.BA.D0.B2_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D1.80.D0.B5.D0.B3.D1.83.D0.BB.D1.8F.D1.80.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B2.D1.8B.D1.80.D0.B0.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F.3F_.D0.9A.D0.B0.D0.BA_.D0.BC.D0.BD.D0.B5_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D1.8C_.D0.B8.D0.BD.D0.B4.D0.B5.D0.BA.D1.81_.D0.B4.D0.BB.D1.8F_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA.D0.B0_.D0.BD.D0.B5.D0.B7.D0.B0.D0.B2.D0.B8.D1.81.D0.B8.D0.BC.D0.BE.D0.B3.D0.BE_.D0.BE.D1.82_.D1.80.D0.B5.D0.B3.D0.B8.D1.81.D1.82.D1.80.D0.B0_.D0.B1.D1.83.D0.BA.D0.B2.3F).

- Во время initdb должна использоваться локаль по умолчанию C, потому что не существует возможности узнать следующий наибольший символ для не C локали. Для таких случаев вы можете создать специальный индекс text_pattern_ops, который работает только для LIKE индексирования. Для поиска слов также можно использовать полнотекстовый индекс.

Также возможно использовать полнотекстовое индексирование для поиска слов.
### Что такое OID?

Если таблица создана с WITH OIDS, то каждая строка получает уникальный идентификатор OID. OID - это автоматически назначаемое уникальное 4-х байтовое целое число, которое уникально для всей установленной СУБД. Однако, после того как его значение превысит 4 миллиарда, значения OID начинают дублироваться. PostgreSQL использует OID для связывания своих внутренних таблиц.

Для уникального значения в строках таблицы пользователя, лучшим способом является создание уникального индекса на колонку OID (но обратите внимание, что выражение WITH OIDS само по себе не создаёт такой индекс).

Система проверяет индекс, чтобы увидеть не существует уже сгенерированный новый OID и если это так, генерирует новый OID и повторяет проверку. Это работает хорошо, пока таблица не содержащая OID имеет только маленькую часть от возможных 4-х миллиардов строк.

PostgreSQL использует OID для идентификаторов объектов в системных каталогах, где вышеописанное ограничение размера не может создавать проблему.

Для уникальной нумерации строк в таблицах пользователей, наилучшим решением будет использование типа SERIAL, вместо колонки OID или BIGSERIAL, если ожидается, что таблица будет иметь более 2-х миллиардов записей.

### Что такое CTID?

CTID используется для идентификации специальных физических записей с блочными значениями и значениями смещений внутри таблицы. Они используются записями индекса, чтобы указать на физические строки в таблице. Логические CTID изменяется после того как строки в таблице были изменены, так что CTID нельзя использовать как долговременный идентификатор строки таблицы. Но иногда использование CTID является удобным для идентификации строки внутри транзакции, когда не ожидается каких-либо обновлений.

### Почему я получаю ошибку "ERROR: Memory exhausted in AllocSetAlloc()"?

Предположительно у вас закончилась виртуальная память или что ваше ядро имеет маленький лимит на определенные ресурсы. Попытайтесь перед запуском сервера БД выполнить следующие команды:

ulimit -d 262144
limit datasize 256m

В зависимости от командного интерпретатора shell, только одна из данных команд выполнится успешно, но она позволит вам установить больший сегмент данных процесса и возможно решит проблему. Эта команда изменяет параметры текущего процесса и всех его потомков, созданных после её запуска. Если у вас возникла проблема с SQL клиентом, потому что backend возвращает слишком большой объем данных, попытайтесь выполнить эту команду перед запуском клиента.
### Какие есть решения для репликации?

Хотя "репликация" -- это единый термин, есть несколько разных технологий для выполнения репликаций с разными особенностями, преимуществами и недостатками для каждой. Наша документация содержит хорошее введение по данной теме в [http://www.postgresql.org/docs/8.3/static/high-availability.html](http://www.postgresql.org/docs/8.3/static/high-availability.html) и по теме особенностей репликации на основе сетевых списков на [Replication, Clustering, and Connection Pooling](https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling "Replication, Clustering, and Connection Pooling")

Репликация Master/slave позволяет иметь один главный (master) сервер для выполнения запросов чтения/записи, в то время как подчинённые (slave) сервера могут производить только запросы чтения/SELECT. Наиболее популярным решением для репликации master-slave в PostgreSQL является Slony-I.

Репликация Multi-master позволяет выполнять запросы чтения/записи на нескольких, реплицируемых друг с другом компьютерах. Эта особенность также приводит к потере производительности, потому что необходима синхронизация изменений между несколькими серверами. Наиболее популярным решением для такой репликации в PostgreSQL является PGcluster.

Существуют также проприетарные и основанные на аппаратном обеспечении решения по репликации, работающие на основе различных репликационных моделей.

### Возможно ли создать кластер серверов PostgreSQL с разделяемым устройством хранения?

PostgreSQL не поддерживает кластеризацию, используя [shared storage](https://wiki.postgresql.org/wiki/Shared_Storage "Shared Storage") на SAN, SCSI-платах, iSCSI томах или других разделяемых носителях. Кластеры такого типа как "RAC-style" не поддерживаются. В настоящий момент поддерживаются только кластеры основанные на репликации.

Подробности см. в [Replication, Clustering, and Connection Pooling](https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling "Replication, Clustering, and Connection Pooling").

Использование [разделяемых устройств хранения](https://wiki.postgresql.org/wiki/Shared_Storage "Shared Storage") в режиме 'failover' возможно, но не безопасно, так как в одно и тоже время более запущен и имеет доступ одним и тем же данным более чем один процесс postmaster. Рекомендуется Heartbeat и [STONITH](http://en.wikipedia.org/wiki/STONITH) или какие-либо другие жёсткие решения по разрыву соединения.

### Почему имена таблицы и колонок не распознаются в в моём запросе? Почему не сохраняются заглавные буквы?

Наиболее часто имена не распознаются из-за использования двойных кавычек в имени таблицы или колонки при создании таблицы. При использовании двойных кавычек, имя таблицы и колонки (которые называют идентификаторами) сохраняются в регистро-зависимом виде; это означает, что вы должны использовать двойные кавычки, когда указываете эти имена в запросе. Некоторые интерфейсы, такие как pgAdmin, во время создания таблицы добавляют двойные кавычки автоматически. Таким образом, чтобы идентификаторы распознавались вы должны следовать одному из следующих правил:

- Избегать использования двойных кавычек при создании таблиц
- Использовать в идентификаторах только символы нижнего регистра
- Использовать двойные кавычки для идентификаторов в запросах

### Я потерял пароль от базы данных. Как я могу его восстановить?

Никак. Однако, вы можете сбросить этот пароль в какое-либо значение. Чтобы сделать это, вы должны

- изменить pg_hba.conf так, чтобы временно предоставить _trust_ авторизацию
- перезагрузить файл конфигурации (pg_ctl reload)
- подключиться к серверу и дать команду ALTER ROLE / PASSWORD чтобы установить новый пароль
- изменить pg_hba.conf снова обратно на старые настройки
- снова перезагрузить файл конфигурации
### Почему мой запрос намного медленнее, чем когда он запускается в виде подготовленного запроса?

Когда PostgreSQL получает полный запрос со всеми параметрами, он может использовать статистику таблицы, чтобы понять являются ли значения, используемые в запросе, часто употребимыми или часто неупотребимыми в какой-либо колонке. Это позволяет изменить способ извлечения данных на более эффективный, так как известно ожидается ли очень много или очень мало результатов из определённой части запроса. Например, PostgreSQL может выбрать последовательное сканирование вместо использования индекса, если осуществляется поиск 'active=y' и при этом известно, что 99% записей в таблице имеют 'active=y', поскольку в этом случае последовательное сканирование будет намного быстрее.

В подготовленном запросе, PostgreSQL не получает значение всех параметров, когда создаёт план запроса. Он должен попытаться создать "безопасный" план, который должен работать хорошо вне зависимости от того какое значение вы предоставите как параметр, когда вы вызовите подготовленный запрос. К сожалению, такой план может не оказаться очень хорошим, если значение, которое вы предоставили гораздо более употребительно или гораздо менее употребительно, чем среднее арифметическое из выбираемых значений в таблице.

Если вы подозреваете, что так оно и есть, запустите команду [EXPLAIN](http://www.postgresql.org/docs/current/static/sql-explain.html), чтобы сравнить медленный и быстрый запросы. Посмотрите вывод команды `EXPLAIN SELECT запрос...` и сравните его с результатами `PREPARE запрос... ; EXPLAIN EXECUTE запрос...`, чтобы увидеть, различаются ли планы запроса. `EXPLAIN ANALYZE` может дать вам больше информации, такой как оценка количества строк и счётчики.

Иногда люди, у которых возникает эта проблема пытаются использовать подготовленные запросы как меру безопасности для предотвращения SQL иньекций, а не как инструмент тонкой настройки производительности тяжёлых запросов, часто запускающихся с различными параметрами. Такие люди должны подумать на использованием подготовленных операторов на стороне клиента, если их клиентский интерфейс (например PgJDBC) их поддерживает.

В настоящий момент, PostgreSQL не предлагает способа запросить перепланировку подготовленного оператора, используя отдельный список значений параметров; если делать так, то несколько теряется смысл подготовленных операторов на стороне сервера. Запуск статистики, чтобы проверить выходит ли конкретное значение параметра сильно за пределами нормы и в автоматическое перепланирование в этом случае обсуждались, по пока не согласованны и не реализованы.

См. [Using_EXPLAIN](https://wiki.postgresql.org/wiki/Using_EXPLAIN "Using EXPLAIN"). Если вы собираетесь обратится за помощью в список рассылки, прочтите [Guide to reporting problems](https://wiki.postgresql.org/wiki/Guide_to_reporting_problems "Guide to reporting problems").

### Почему мой запрос намного медленнее, когда он запускается в функции?

См. [#Почему мой запрос намного медленнее, чем когда он запускается в виде подготовленного запроса?](https://wiki.postgresql.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%BE_%D0%97%D0%B0%D0%B4%D0%B0%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5_%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B#.D0.9F.D0.BE.D1.87.D0.B5.D0.BC.D1.83_.D0.BC.D0.BE.D0.B9_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81_.D0.BD.D0.B0.D0.BC.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BC.D0.B5.D0.B4.D0.BB.D0.B5.D0.BD.D0.BD.D0.B5.D0.B5.2C_.D1.87.D0.B5.D0.BC_.D0.BA.D0.BE.D0.B3.D0.B4.D0.B0_.D0.BE.D0.BD_.D0.B7.D0.B0.D0.BF.D1.83.D1.81.D0.BA.D0.B0.D0.B5.D1.82.D1.81.D1.8F_.D0.B2_.D0.B2.D0.B8.D0.B4.D0.B5_.D0.BF.D0.BE.D0.B4.D0.B3.D0.BE.D1.82.D0.BE.D0.B2.D0.BB.D0.B5.D0.BD.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81.D0.B0.3F). Запросы в функциях PL/PgSQL подготавливаются и кэшируются, так что они запускаются преимущественно тем же способом, что и при выполнении вами `PREPARE`, а затем `EXECUTE`.

Если у вас действительно серьёзные проблемы с этим и сбор статистики для таблиц или настройка вашего запроса не помогают, то вы можете обойти это, используя PL/PgSQL для переподготовки вашего запроса при каждом его выполнении. Чтобы сделать это, используйте оператор `EXECUTE ... USING` в PL/PgSQL, чтобы указать ваш запрос как текстовую строку. В качестве альтернативы могут быть использованы функции [quote_literal или quote_nullable](http://www.postgresql.org/docs/current/static/functions-string.html), чтобы избежать подстановки параметров в текст запроса.
### Что такое Курсор? Как использовать Курсор?  
Курсор базы данных — это управляющая структура, позволяющая просматривать записи в базе данных. Курсоры, кроме того, облегчают обработку после обхода, такую как поиск, добавление и удаление записей базы данных. Их можно рассматривать как указатель на одну строку в наборе строк.  
  
**Работа с SQL-курсором:**  

1. **DECLARE** курсор после объявления любой переменной. Объявление курсора всегда должно быть связано с оператором SELECT.
2. Откройте курсор, чтобы инициализировать результирующий набор. Оператор **OPEN** должен вызываться перед выборкой строк из результирующего набора.
3. **Оператор FETCH** для извлечения и перехода к следующей строке в результирующем наборе.
4. Вызовите оператор **CLOSE** , чтобы деактивировать курсор.
5. Наконец, используйте оператор **DEALLOCATE** , чтобы удалить определение курсора и освободить связанные ресурсы.
### Что такое сущности и отношения?  
**Сущность** : Сущность может быть объектом реального мира, материальным или нематериальным, который можно легко идентифицировать. Например, в базе данных колледжа студенты, преподаватели, работники, отделы и проекты могут называться объектами. Каждая сущность имеет некоторые связанные свойства, которые обеспечивают ее идентичность.  
**Отношения** : Отношения или связи между сущностями, которые имеют какое-то отношение друг к другу. Например, таблица сотрудников в базе данных компании может быть связана с таблицей зарплат в той же базе данных.
### Перечислите различные типы отношений в SQL.  

- **Один к одному** . Это можно определить как связь между двумя таблицами, где каждая запись в одной таблице связана с максимум одной записью в другой таблице.
- **«Один ко многим» и «Многие к одному»** — это наиболее часто используемая связь, когда запись в таблице связана с несколькими записями в другой таблице.
- **«Многие ко многим** » — используется в случаях, когда для определения отношения необходимо несколько экземпляров с обеих сторон.
- **Самореферентные отношения** — используется, когда таблице необходимо определить отношения с самой собой.
## Что такое оптимизатор SQL-запросов и как он работает?

Оптимизатор SQL-запросов — это программный компонент системы управления базами данных (СУБД), который автоматически генерирует наиболее эффективный план выполнения для заданного запроса. Он анализирует запрос, учитывает доступные индексы, статистику по таблицам и другую информацию, чтобы сгенерировать план выполнения, минимизирующий затраты на доступ к данным и их обработку.

Оптимизатор запросов изучает синтаксис запроса, определяет таблицы и столбцы и выбирает наилучший способ получения и объединения данных. При этом он рассматривает несколько стратегий и оценивает их на основе стоимости, которая обычно измеряется в терминах дискового ввода-вывода, использования процессора и памяти. Цель оптимизатора — найти план выполнения, который требует наименьшего количества ресурсов для получения и обработки данных.
### Что такое хранимая процедура и каковы её преимущества?

Хранимая процедура — это предварительно скомпилированный набор операторов SQL, который хранится в базе данных и может быть выполнен одной командой. Хранимые процедуры предназначены для упрощения сложных операций, повышения производительности и усиления безопасности, позволяя администраторам контролировать доступ к важным операциям БД.

Вот пример простой хранимой процедуры, которая извлекает данные из базы:

CREATE PROCEDURE get_customers

AS

BEGIN

SELECT * FROM customers;

END

Эта хранимая процедура извлекает все строки из таблицы “customers” и возвращает их вызывающей стороне. Процедура может быть выполнена одной командой:

EXEC get_customers;

### Преимущества хранимых процедур

1. **Повышенная производительность.** Хранимые процедуры компилируются и оптимизируются движком базы данных, что может привести к более быстрому выполнению операции, чем специальные SQL-запросы.
2. **Возможность повторного использования**. Хранимые процедуры можно вызывать из нескольких приложений и использовать для выполнения сложных операций с базой данных, что сокращает объем кода, который необходимо писать и поддерживать.
3. **Безопасность**. Хранимые процедуры можно использовать для контроля доступа к конфиденциальным операциям базы данных, ограничивая доступ определенным пользователям или ролям. Это помогает предотвратить несанкционированный доступ.
4. **Удобство обслуживания**. Хранимые процедуры можно изменять, не затрагивая использующие их приложения. Это облегчает внесение изменений в схему базы данных или логику запросов без разрушения существующих приложений.
5. **Согласованность**. Хранимые процедуры позволяют обеспечивать согласованность операций с базой данных, инкапсулируя сложную логику и применяя бизнес-правила. Это помогает предотвратить возникновение различных ошибок.
## Что такое представление SQL и как оно используется?

Представление (VIEW) — это виртуальная таблица, которая является производной от одной или нескольких таблиц в базе данных. Такие виртуальные таблицы используются для упрощения сложных запросов, представляя данные в более организованном и осмысленном виде. Они также могут использоваться для соблюдения политики безопасности, скрытия конфиденциальной информации и сокращения объема данных, которые необходимо извлекать из БД.

Для создания представления можно использовать оператор CREATE VIEW. Вот пример представления, которое извлекает информацию из двух таблиц:

CREATE VIEW employee_salary AS

SELECT employee_name, salary

FROM employee_info

JOIN salary_info ON employee_info.employee_id = salary_info.employee_id;

В этом примере представление “employee_salary” объединяет данные из двух таблиц “employee_info” и “salary_info”, соединяя их по столбцу “employee_id”. Представление возвращает только два столбца, “employee_name” и “salary”, и скрывает остальные столбцы из исходных таблиц.

После создания представления его можно использовать в SQL-запросах так же, как и обычную таблицу. Например, вы можете использовать представление “employee_salary” для получения данных о зарплате всех сотрудников компании:

SELECT * FROM employee_salary;

Этот запрос вернет набор результатов с двумя столбцами, “employee_name” и “salary”, который включает всех сотрудников в “employee_info” таблице.

### Важность представлений

Представления SQL обеспечивают ряд преимуществ для администраторов баз данных и разработчиков:

1. **Упрощение сложных запросов.** Представления позволяют скрывать сложность объединений, подзапросов и других продвинутых функций. Это облегчает написание и сопровождение SQL-запросов с течением времени.
2. **Усиление безопасности**. Представления можно использовать для обеспечения соблюдения политики безопасности, скрывая конфиденциальную информацию от пользователей, не имеющих разрешения на доступ к ней.
3. **Улучшение производительности**. С помощью представлений можно уменьшать объем данных, которые необходимо извлечь из БД, отфильтровывая всё лишнее. Это позволяет повысить производительность запросов и снизить нагрузку на сервер.
4. **Уменьшение дублирования кода**. Представления можно использовать для устранения дублирования кода, предоставляя единый источник информации для сложных SQL-запросов. Это облегчает сопровождение и обновление кода SQL с течением времени.
5. **Упрощение анализа данных**. Представления помогают более наглядно представлять данные аналитикам и бизнес-пользователям. Это позволяет лучше понять сложные взаимосвязи между данными и принять более обоснованные решения.

В заключение можно сказать, что представления SQL — это мощный инструмент для упрощения сложных SQL-запросов, обеспечения политик безопасности и повышения производительности запросов. Создавая и используя представления в коде SQL, вы можете улучшить поддерживаемость и масштабируемость баз данных своих приложений, а также обеспечить более осмысленный и безопасный пользовательский опыт.
## Что такое оператор CASE и как он используется?

CASE используется для создания условного выражения в запросе. Он позволяет оценить набор условий и вернуть значение, основанное на условии, которое является истинным.
### Что такое SQL-профилировщик?

SQL Profiler — это инструмент, который позволяет системному администратору отслеживать события на SQL-сервере. В основном это используется для сбора и сохранения данных о каждом событии файла или таблицы для анализа.
### В чем разница между локальными и глобальными временными таблицами?

- Локальные временные таблицы видны при наличии соединения и удаляются при его закрытии.

- Глобальные временные таблицы видны всем пользователям и удаляются при закрытии соединения, создавшего их.#

### Что такое ограничение CHECK?

Ограничение CHECK можно применить к столбцу таблицы, чтобы ограничить значения, которые можно поместить в столбец. Ограничение проверки предназначено для обеспечения целостности.
### Как обрабатываются исключения при программировании SQL Server?

Исключения обрабатываются с помощью конструкций TRY--CATCH и обрабатываются путем написания сценариев внутри блока TRY и обработки ошибок в блоке CATCH.
### Какова цель функции FLOOR?

Функция FLOOR используется для округления нецелого значения до предыдущего наименьшего целого числа.
### Что такое столбец IDENTITY в операторах вставки?

Столбец IDENTITY используется в столбцах таблицы, чтобы сделать этот столбец автоматически увеличивающимся номером или суррогатным ключом.
### **Какие типы СУБД в соответствии с моделями данных вы знаете?**

Существует несколько типов СУБД:

1. Реляционные, которые поддерживают установку связей между таблицами с помощью первичных и внешних ключей. Пример — MySQL.
2. Flat File — базы данных с двумерными файлами, в которых содержатся записи одного типа и отсутствует связь с другими файлами, как в реляционных. Пример — Excel.
3. Иерархические подразумевают наличие записей, связанных друг с другом по принципу отношений один-к-одному или один-ко-многим. А вот для отношений многие-ко-многим следует использовать реляционную модель. Пример — Adabas.
4. Сетевые похожи на иерархические, но в этом случае «ребёнок» может иметь несколько «родителей» и наоборот. Примеры — IDS и IDMS.
5. Объектно-ориентированные СУБД работают с базами данных, которые состоят из объектов, используемых в ООП. Объекты группируются в классы и называются экземплярами, а классы в свою очередь взаимодействуют через методы. Пример — Versant.
6. Объектно-реляционные обладают преимуществами реляционной и объектно-ориентированной моделей. Пример — IBM Db2.

Многомерная модель является разновидностью реляционной и использует многомерные структуры. Часто представляется в виде кубов данных. Пример — Oracle Essbase.
#### Что такое "шаблон проектирования" в контексте базы данных SQL?

**Ответ**: В контексте баз данных SQL, "шаблон проектирования" —это шаблон организации структуры базы данных, создания связей между таблицами и выполнения типичных операций обработки данных. Одним из наиболее распространенных шаблонов проектирования для баз данных является "Сущность-Связь" (Entity-Relationship, ER)

 В модели ER присутствуют следующие акторы:

- **Сущность** представляет собой объект, который может быть идентифицирован в контексте информационной системы. Сущности соответствуют таблицам в базе данных. 
    
- **Атрибуты** — это характеристики или свойства сущности. Атрибуты соответствуют полям (столбцам) в таблице базы данных.
    
- **Связи** определяют, как сущности связаны друг с другом. Например, сущность "Студент" может быть связана со сущностью "Курс" через связь "Регистрация на курс". Эти связи могут быть один-к-одному, один-ко-многим, многие-ко-многим.
    

Модель ER часто изображается в виде диаграммы с графическим представлением структуры базы данных. Эта диаграмма помогает СА и разработчикам понять, как данные связаны и взаимодействуют друг с другом, прежде чем реализовывать базу данных.
# Общие особенности баз данных
## Вопросы
- **Как создать резервную копию базы данных?**
    
    - **Ответ:** В зависимости от СУБД, команды для создания резервной копии различаются. Например, в MySQL используется команда `mysqldump`, в PostgreSQL — `pg_dump`. Эти команды создают дамп базы данных, который может быть восстановлен позже.
- **Что такое триггеры в базе данных?**
    
    - **Ответ:** Триггеры это специальные процедуры, которые автоматически выполняются при определенных событиях в таблице, таких как INSERT, UPDATE или DELETE. Они используются для обеспечения целостности данных и выполнения автоматических операций.
- **Каковы преимущества использования хранимых процедур?**
    
    - **Ответ:** Хранимые процедуры обеспечивают повышение производительности, так как выполняются на стороне сервера; улучшают безопасность, ограничивая прямой доступ к данным; обеспечивают повторное использование кода и централизованное управление бизнес-логикой.
- **Что такое целостность данных?**
    
    - **Ответ:** Целостность данных это состояние данных, при котором они остаются точными, согласованными и достоверными. Целостность данных обеспечивается с помощью ограничений, транзакций, триггеров и других механизмов базы данных.
- **Каковы основные различия между SQL и NoSQL базами данных?**
    
    - **Ответ:** SQL базы данных реляционные и используют структурированные схемы и SQL для управления данными. NoSQL базы данных нереляционные, более гибкие в плане схемы и используют разнообразные модели данных, такие как документные, графовые, колоночные и ключ-значение.
- **Что такое партиционирование таблиц?**
    
    - **Ответ:** Партиционирование таблиц это процесс разделения большой таблицы на более мелкие, управляемые части (партиции) для улучшения производительности и управления данными. Партиции могут быть организованы по диапазону, списку, хэшированию или другим критериям.
- **Что такое CTE (Common Table Expression) в SQL?**
    
    - **Ответ:** CTE это временный результат, определяемый в предложении `WITH` и используемый в следующем SELECT, INSERT, UPDATE или DELETE запросе. CTE упрощает написание и понимание сложных запросов.
- **Как вы объясните концепцию "конкурентного доступа" в базах данных?**
    
    - **Ответ:** Конкурентный доступ происходит, когда несколько транзакций одновременно обращаются к одним и тем же данным. Это может привести к проблемам, таким как гонки данных, грязное чтение и фантомные чтения. Механизмы блокировок и уровни изоляции помогают управлять конкурентным доступом.
- **Что такое материализованные представления (materialized views)?**
    
    - **Ответ:** Материализованные представления это предвычисленные результаты SQL-запросов, хранящиеся как физические таблицы. Они используются для ускорения выполнения часто выполняемых запросов, но требуют периодического обновления.
- **Как происходит обновление данных в базе данных с высокой нагрузкой?**
    
    - **Ответ:** В высоконагруженных базах данных обновления выполняются с использованием транзакций, блокировок, индексов и оптимизированных запросов. Также могут использоваться техники, такие как шардирование и партиционирование для распределения нагрузки.
- **Что такое ER-диаграмма и для чего она используется?**
    
    - **Ответ:** ER-диаграмма (Entity-Relationship Diagram) это графическое представление сущностей, атрибутов и их связей в базе данных. Она используется для проектирования базы данных и понимания её структуры.
- **Что такое SQL-инъекции и как их предотвращать?**
    
    - **Ответ:** SQL-инъекции это атаки, при которых злоумышленники вставляют вредоносные SQL-коды в запросы для выполнения несанкционированных операций с базой данных. Их предотвращение достигается использованием параметризованных запросов и подготовленных выражений.
- **Каковы преимущества и недостатки использования денормализации?**
    
    - **Ответ:** Преимущества денормализации включают улучшение производительности запросов и упрощение схемы данных. Недостатки — увеличение избыточности данных и сложности управления ими, возможные проблемы с согласованностью данных.
- **Что такое Redis и для чего он используется?**
    
    - **Ответ:** Redis это высокопроизводительная нереляционная база данных типа "ключ-значение" с поддержкой множества структур данных. Он используется для кэширования, управления сессиями, очередей сообщений и других задач, требующих быстрой обработки данных.
**Чем отличаются `CHAR` и `VARCHAR` типы данных в SQL?**
- `CHAR` хранит строку фиксированной длины, а `VARCHAR` хранит строку переменной длины.
- Например, `CHAR(10)` всегда будет занимать 10 байт, даже если строка короче, в то время как `VARCHAR(10)` будет занимать только столько места, сколько необходимо для хранения конкретной строки.
## Типы БД

1. Реляционная база данных — это набор данных с предопределенными связями между ними. Данные хранятся в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке — значение атрибута.
2. Нереляционные системы (NoSQL) — системы, созданные для определенных моделей данных, обладающие гибкими схемами. Иначе говоря, это БД, которые хранят данные не в виде табличных схем, строк и столбцов, а в иных форматах.
## Из за чего возможно снижение скорости записи?
Из за того что несколько транзакций пытаются переписать поле в базе данных(race condition)

## Денормализация

Денормализация — намеренное снижение или нарушение форм нормализации базы данных, обычно — чтобы ускорить чтение из базы за счет добавления избыточных данных. В общем, это процесс, обратный к нормализации. Так происходит потому, что теория нормальных форм не всегда применима на практике. К примеру, не атомарные значения — не всегда «зло»: иногда даже наоборот. В некоторых случаях необходимо дополнительное объединение при выполнении запросов, особенно при обработке большого массива информации. В итоге это может улучшить производительность. Для баз данных, предназначенных для аналитики, часто выполняют денормализацию, чтобы ускорить выполнение запросов.
## В чем разница между кластеризованным и некластеризованным индексами в SQL?

#### Кластеризованный:

- Обеспечивает физический порядок по выбранному полю;
- Если у таблицы есть кластеризованный индекс, она называется кластеризованной;
- Нужно не более одного индекса на таблицу;
- В MySQL кластеризованный индекс не задается явно пользователем, так как если вы не определяете PRIMARY KEY для своей таблицы, MySQL находит первый индекс `UNIQUE`, где все ключевые столбцы — `NOT NULL`, и InnoDB использует его в качестве кластеризованного индекса.

#### Некластеризованный:

- В одной таблице возможно до 999 некластеризованных индексов;
- Содержит указатель на строки с реальными данными в таблице;
- Не обеспечивает физический порядок;
- Для некластеризованных индексов присутствуют отдельные таблицы с отсортированными данными, а именно — одна таблица для одного столбца, на котором индекс, поэтому при запросе данных, не входящих в состав данного поля, будет сначала выполняться запрос к полю в данной таблице, а только затем — дополнительный запрос к строке в изначальной таблице.
## Что такое составной индекс?

Составной индекс — построенный с посыланием на несколько колонок одновременно. Иначе говоря, это комплексный индекс, состоящий из нескольких колонок.
## Что такое покрывающий индекс? Уникальный индекс?

Покрывающий индекс — это индекс, которого вполне достаточно для ответа на запрос без обращения к самой таблице. По этому индексу можно достать всю строку данных, но по факту это просто не нужно. Благодаря тому, что не нужно ходить непосредственно в исходную таблицу, а ответить можно, используя только индекс, покрывающие индексы немного быстрее в использовании. При этом не стоит забывать, что чем больше колонок, тем более громоздким и медленным становится сам индекс. Так что злоупотреблять этим не стоит. Выше мы говорили о кластеризованных и некластеризованных индексах, которые могут быть уникальными.
## Уровни изолированности транзакций

Каждый уровень изолированности разрешает/запрещает определенные действия (возможности):

- фантомное чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за добавления данных другой (параллельной) транзакцией.
- неповторяющееся чтение — в рамках одной транзакции один и тот же запрос данных дает разные результаты, что происходит из-за изменения или удаления данных другой (параллельной) транзакцией.
- «грязное» чтение — чтение данных, добавленных или измененных транзакцией, которая впоследствии не откатится;
- потерянное обновление — при одновременном изменении одного блока данных разными транзакциями теряются все изменения, кроме последнего (похоже на “состояние гонки” в многопоточности).
## Что такое SQL-инъекция?

SQL-инъекция — один из способов взлома сайта, суть которого — внедрение в данные через `GET`, `POST` запросы или Cookie некоторого SQL кода. Если веб-сайт выполняет такие инъекции, можно получить доступ к БД и взломать приложение. Например, мы знаем имя некоторой переменной. Допустим, `column_name` с типом `boolean`. Если система восприимчива к инъекциям, можно добавить `OR column_name=true` и после этого писать всё, что нам нужно от БД. `OR` создаст условие ИЛИ, и наше выражение после него будет всегда `true`, что и пропустит нас дальше. Атака на сайт вроде инъекции SQL возможна из-за неправильной обработки входящих данных, используемых в SQL-запросах. При соединении с базой данных при помощи [JDBC](https://javarush.com/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja) вы используете различные `Statements`. Для повышения безопасности необходимо использовать `PreparedStatement` вместо обычного `Statement`, так как при использовании `Statement` строки запроса и значений просто складываются, делая возможными инъекции. В свою очередь, в `PreparedStatement` есть конкретный шаблон запроса, и данные в него вставляются с отражением кавычек. В итоге SQL-инъекции будут восприниматься только как строковое представление какого-то поля.
## Что такое хранимые процедуры? Хранимые функции? Триггер?

Хранимые процедуры в SQL — сущность в БД, представляющая собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Словом, это аналог методов в Java. Хранимые процедуры могут выполнять действия над данными как обычные запросы, так и некоторые действия, недоступные для обычных запросов. Процедура является сущностью SQL, которую создают один раз, а затем вызывают, передавая аргументы. Плюс этого подхода состоит в том, что данные инструкции можно переиспользовать не единожды. Хранимые процедуры увеличивают производительность, расширяют возможности программирования и поддерживают функции безопасности данных.
Хранимая функция — это разновидность хранимой процедуры. Отличие функции состоит в том, что она всегда возвращает только единичное значение, а процедура — набор значений. Хранимые процедуры нельзя смешивать с обычным SQL, в то время как с сохраненной функцией это можно — и это ее преимущество. С другой стороны, у хранимых функций гораздо больше ограничений, нежели у процедур.
Триггер — еще одна разновидность хранимой процедуры, которая вызывается не непосредственно пользователем, а ее активация происходит при модификации данных. То есть эта процедура активируется при выполнении некоторых условий, как, например, `INSERT` или `DELETE`, или `UPDATE` данных в определенном столбце данной таблицы. Момент запуска триггера определяется с помощью ключевых слов `BEFORE` (триггер запускается до связанного события) или `AFTER` (после события).

## Индексы
### Селективность индексов
### Основные понятия

1. **Селективность (Selectivity)**:
    
    - Селективность индекса определяется как отношение количества уникальных значений к общему количеству строк в таблице.
    - Высокая селективность означает, что значений много и они редко повторяются (например, индекс по уникальному идентификатору).
    - Низкая селективность означает, что значений мало и они часто повторяются (например, индекс по столбцу с ограниченным числом возможных значений, как "пол").
2. **Эффективность селективных индексов**:
    
    - Высокоселективные индексы (индексы с высокой селективностью) более эффективны, потому что они позволяют быстро отфильтровывать большое количество строк.
    - Низкоселективные индексы менее эффективны, поскольку фильтрация происходит не так эффективно и может потребоваться просмотр большого количества строк.

### Примеры использования

- **Индексы на уникальных столбцах**: Индексы на первичных ключах или уникальных столбцах являются высокоселективными, так как каждый ключ соответствует одной строке.
- **Индексы на столбцах с широким разбросом значений**: Столбцы с большим количеством различных значений, такие как номера телефонов, адреса электронной почты и т.д., также будут высокоселективными.

**Примеры**:
хороший- уникальный id сотрудника
плохой - пол человека
### Виды индексов
- **Кластерные индексы (Clustered Indexes)**:
    
    - Хранят строки данных в таблице в соответствии с порядком индекса.
    - Таблица может иметь только один кластерный индекс.
    - Влияет на физический порядок строк на диске.
- **Некластерные индексы (Non-Clustered Indexes)**:
    
    - Содержат копии ключевых полей и указатели на строки данных.
    - Таблица может иметь множество некластерных индексов.
    - Не изменяют физический порядок строк в таблице.
- **Уникальные индексы (Unique Indexes)**:
    
    - Гарантируют уникальность значений в одном или нескольких столбцах.
    - Могут быть как кластерными, так и некластерными.
- **Полнотекстовые индексы (Full-Text Indexes)**:
    
    - Используются для поиска текстовых данных в столбцах.
    - Поддерживают поиск по фразам и ключевым словам.
- **Геопространственные индексы (Spatial Indexes)**:
    
    - Оптимизируют запросы, работающие с географическими данными, такими как координаты.
    - Используются для эффективного выполнения пространственных запросов.
- **XML-индексы (XML Indexes)**:
    
    - Предназначены для индексации XML-данных.
    - Позволяют быстро выполнять запросы к данным, хранящимся в формате XML.
- **Партиционные индексы (Partitioned Indexes)**:
    
    - Индексы, разделенные на части, которые соответствуют разделам таблицы.
    - Используются для улучшения производительности и управляемости больших таблиц.
- **Функциональные индексы (Function-Based Indexes)**:
    
    - Индексы, созданные на основе выражения или функции, примененной к одному или нескольким столбцам.
    - Позволяют индексировать данные, полученные в результате вычислений.
- **Bitmap-индексы (Bitmap Indexes)**:
    
    - Используются для столбцов с небольшим числом уникальных значений.
    - Хранят информацию в виде битовых массивов, что позволяет эффективно выполнять логические операции.
## Транзакции
Транзакции в базах данных – это последовательность операций, которые выполняются как единое целое, чтобы обеспечить согласованность и целостность данных. Основные характеристики транзакций можно описать через свойства ACID:
### ACID
1. **Atomicity (Атомарность)**: Транзакция выполняется полностью или не выполняется вовсе. Если одна из операций транзакции не удается, все выполненные операции откатываются, и база данных возвращается в состояние, в котором она была до начала транзакции.
    
2. **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое. Это означает, что любые правила и ограничения целостности данных соблюдаются как до начала, так и после завершения транзакции.
    
3. **Isolation (Изолированность)**: Изолированность гарантирует, что параллельно выполняемые транзакции не влияют друг на друга. Каждая транзакция должна быть изолирована от других, чтобы ее промежуточные состояния не были видны другим транзакциям.
    
4. **Durability (Долговечность)**: Долговечность гарантирует, что изменения, внесенные успешной транзакцией, будут сохранены даже в случае сбоя системы.
### Уровни изоляции транзакции
Существует несколько уровней изолированности транзакций, которые определяют, как параллельные транзакции могут видеть изменения друг друга:

1. **Read Uncommitted**: Транзакция может видеть изменения, сделанные другими незавершенными транзакциями.
2. **Read Committed**: Транзакция видит только те изменения, которые были зафиксированы другими транзакциями.
3. **Repeatable Read**: Транзакция видит данные такими, какими они были в момент начала транзакции, даже если другие транзакции вносят изменения.
4. **Serializable**: Транзакции выполняются последовательно, одна за другой, что предотвращает любые возможные конфликты.
## Репликация
Репликация (replication) в базах данных — это процесс автоматического создания и поддержания копий данных с одной базы данных (или набора данных) на другую. Целью репликации является обеспечение доступности данных, повышение отказоустойчивости системы, а также улучшение производительности путем распределения запросов между репликами.

Вот основные аспекты репликации:

1. **Типы репликации**:
    
    - **Мастер-мастер (Master-Master)**: Оба сервера могут принимать записи и реплицировать их друг на друга. Этот тип репликации обеспечивает высокую отказоустойчивость и распределение нагрузки между узлами.
    - **Мастер-слейв (Master-Slave)**: Один сервер (мастер) принимает записи, а другие серверы (слейвы) получают их для чтения. Этот тип репликации полезен для повышения доступности данных и распределения нагрузки на чтение.
    - **Логическая и физическая репликация**: Логическая репликация копирует логическое изменение данных, в то время как физическая репликация копирует физические файлы данных.
2. **Цели репликации**:
    
    - **Высокая доступность**: При отказе одного сервера данные остаются доступными на других серверах.
    - **Масштабируемость чтения**: Распределение запросов на чтение между несколькими серверами может повысить производительность системы.
    - **Защита от потери данных**: Репликация может служить средством резервного копирования данных, предотвращая потерю данных в случае сбоев или аварий.
3. **Сценарии применения**:
    
    - **Глобальная доступность**: Когда требуется, чтобы данные были доступны в разных частях мира, репликация помогает минимизировать задержки доступа к данным.
    - **Отчеты и аналитика**: Репликация позволяет распределять запросы для отчетов и аналитических задач на слейвы, не влияя на производительность операционной базы данных.
    - **Бэкапы**: Использование репликации для создания резервных копий данных, которые могут использоваться для восстановления после сбоев.
# Postgre
## Виды индексов в Postgre
- **Hash Indexes**: Используются для равенства, но не для диапазонных запросов.
- **GiST (Generalized Search Tree) Indexes**: Подходят для геометрических данных, полнотекстового поиска и других специальных типов данных.
- **SP-GiST (Space-Partitioned Generalized Search Tree) Indexes**: Оптимизированы для данных с неравномерным распределением.
- **GIN (Generalized Inverted Index) Indexes**: Используются для индексации массивов, JSONB и полнотекстового поиска.
- **BRIN (Block Range INdex) Indexes**: Оптимизированы для очень больших таблиц с данными, отсортированными по определенному столбцу.
### Индексы B-дерева (B-tree Indexes)

1. **Структура**:
    
    - B-дерево является сбалансированным деревом поиска.
    - В каждом узле дерева содержится ключи, а также указатели на дочерние узлы.
    - Листовые узлы содержат указатели на строки данных.
2. **Применение**:
    
    - Подходит для диапазонных запросов, точного поиска, сортировки и других операций.
    - Эффективен для столбцов, используемых в WHERE, ORDER BY, и GROUP BY операциях.
## Какой вид индексов обычно используется в PostgreSQL
B-tree - сбалансированное бинарное дерево
## Особенности транзакций
- Точка сохранения (Savepoints)**: PostgreSQL поддерживает точки сохранения внутри транзакций с помощью команды `SAVEPOINT`, что позволяет откатывать часть транзакции до определенного момента без отмены всей транзакции.
- **Управление конкуренцией**: PostgreSQL предоставляет мощные средства управления конкуренцией, такие как блокировки различных уровней, что позволяет избегать конфликтов и обеспечивать изоляцию между параллельными транзакциями.
- **Транзакционные свойства**: В PostgreSQL можно задавать различные транзакционные свойства, такие как `READ ONLY` (транзакция только для чтения) и `DEFERRABLE` (отложенная проверка ограничений целостности).
# Redis
### Что такое Редис?

Redis — это расширенное хранилище и кеш данных «ключ-значение». Его также называют сервером структуры данных, поскольку ключи содержат не только строки, но также хеши, наборы, списки и отсортированные наборы. Компании, использующие Redis, включают StackOverflow, Twitter, Github и т. д.
### Объясните функцию репликации Redis?

Redis поддерживает простую репликацию master-slave. Когда связь установлена, данные от ведущего передаются ведомому. Как только это будет сделано, все изменения ведущего устройства реплицируются на ведомое устройство.
### В чем разница между Memcached и Redis?

|   |   |
|---|---|
|**Redis**|**Memcached**|
|- Redis также кэширует информацию, но имеет дополнительные функции, такие как сохранение и репликация.<br>- Redis не поддерживает функцию вытеснения значений LRU (наименее недавно использовавшуюся).<br>- В Redis вы можете установить тайм-аут для всего, когда память заполнена, он будет просматривать три случайных ключа и удалять тот, срок действия которого истекает ближе всего.<br>- Redis не поддерживает CAS (Проверить и установить). Это полезно для поддержания согласованности кэша.<br>- Redis имеет более прочные структуры данных; он может обрабатывать строки, двоичные безопасные строки, список двоичных безопасных строк, отсортированные списки и т. д.<br>- У Redis максимальная длина ключа составляла 2 ГБ.<br>- Redis является однопоточным|-  Memcached кэширует только информацию.<br>- Memcached поддерживает функцию вытеснения значений LRU (наименее недавно использовавшуюся).<br>- В Memcached, когда они переполняют память, тот, который вы недавно не использовали (LRU — последний раз использованный), будет удален.<br>- Memcached поддерживает CAS (проверка и установка)<br>- В Memcached вам необходимо сериализовать объекты или массивы, чтобы сохранить их, а для их обратного чтения необходимо отменить сериализацию.<br>- Memcached имел максимальную длину 250 байт.<br>- Memcached — это многопоточный|
### Каковы преимущества использования Redis?

Преимущество использования Redis

- Он обеспечивает высокую скорость
- Он поддерживает блокировку на стороне сервера.
- У него много клиентских библиотек.
- У него есть командный уровень Atomic Operation (операция tx).
### Каковы ограничения Redis?

- Он однопоточный
- Имеет ограниченную клиентскую поддержку для последовательного хеширования.
- Он имеет значительные накладные расходы на постоянство
- Он не получил широкого распространения
### Перечислите клавиши управления Redis?

Ключи управления Redis включают в себя

- ТИП ключ
- ключ TTL
- КЛЮЧИ шаблон
- EXPIRE ключевые секунды
- Метка времени EXPIREAT ключа
- СУЩЕСТВУЕТ ключ
- Клавиша DEL
### Обеспечивает ли Redis скорость и долговечность одновременно?

Нет, Redis намеренно снижает надежность ради повышения скорости. В Redis в случае сбоя или сбоя системы Redis записывает на диск, но может отстать и потерять данные, которые не сохранены.
### Как повысить надежность Redis?

Чтобы повысить надежность Redis **«добавить только файл»** можно настроить с помощью данных fsync на диске.

- Fsync() каждый раз, когда в файл журнала добавления добавляется новая команда: это безопасно, но очень медленно.
- Fysnc() один раз в секунду: это быстро, но вы можете потерять 1 секунду данных в случае сбоя системы.
- Никогда fsync(): это небезопасный метод, и ваши данные находятся в руках Operating System
### Упомяните, о чем вам следует помнить при использовании Redis

При использовании Redis необходимо позаботиться о

- Выберите единый метод для присвоения имени и префикса вашим ключам. Управляйте своим пространством имен
- Создайте «Реестр» ключевых префиксов, который сопоставляет каждый из ваших внутренних документов с тем приложением, которое «владеет» ими.
- Для каждого класса, который вы внедряете в свою инфраструктуру Redis: спроектируйте, внедрите и протестируйте механизмы сбора мусора или переноса данных в архивное хранилище.
- Спроектируйте, внедрите и протестируйте библиотеку сегментирования, прежде чем вкладывать значительные средства в развертывание приложения, и убедитесь, что вы ведете реестр «осколков», реплицируемых на каждом сервере.
- Отделите все свои магазины K/V и связанные с ними операции в свою собственную библиотеку/API или сервис.