#собеседование #чистый #код



## 1. Будь проще, Саймон (Keep It Simple Simon, KISS)

При написании следующего большого проекта убедитесь, что ваш код прост и понятен. Код не должен вызывать затруднений у людей при модификации или изменении.

- Ваши методы должны быть небольшими, не превышающими 40-50 строк.
    

- Каждый метод должен решать только одну проблему.
    

- У вас в проекте много условий? Убедитесь, что вы разбили их на более мелкие блоки кода.
    

Always Keep It Simple, Stupid (KISS) позволяет вам и другим программистам быстро выявлять ошибки. Он также помогает вносить дальнейшие изменения в код. Это один из наиболее распространенных принципов бережливого производства в гибкой разработке программного обеспечения.

## 2. Вам это не понадобится (You Aren't Gonna Need It, YAGNI)

Большинство программистов с самого начала попадают в ловушку, пытаясь реализовать все функции сразу. В конце концов, часть или большинство из этих функций становятся бесполезными.

Как развивающийся разработчик программного обеспечения, всегда начинайте с добавления всего нескольких методов в класс. Когда ваш проект начнет обретать форму и возникнут новые требования, вы можете добавить больше функций. Таким образом, вы будете придерживаться принципов бережливой разработки программного обеспечения.

Этот принцип экономит время, усилия и расходы, которые тратятся впустую на попытки понять или отладить код.

## 3. Дважды отмерь и один раз отрежь (Measure Twice and Cut Once)

Некачественно выполненный этап написания требований обычно приводит к более чем 50% проблем в разработке. Поэтому подготовьтесь, разработав системный подход к процессу программирования.

Дважды проверьте все требования проекта, чтобы убедиться, что вы ничего не упускаете и не добавляете лишнего в свой код. После этого сделайте наброски, которые будут направлять весь процесс для получения высококачественного кода. Всегда тестируйте свой проект с самых основ, чтобы убедиться, что все в порядке.

Этот принцип дает гораздо более предсказуемые результаты, особенно если стоимость проекта уже высока. Вы избавите себя от головной боли, связанной с удалением или добавлением строк кода в соответствии с требованиями.

## 4. Не повторяйся (Don’t Repeat Yourself, DRY)

При написании кода не повторяйтесь. То есть избегайте копирования кода в разные места. В противном случае дальнейшее обслуживание будет трудным. Причина в том, что вам придется изменять код в разных местах.

Эти изменения затронут и тесты, которые нужно будет починить. Для этого потребуется больше времени, усилий и денег.

Чтобы избежать этой ловушки, вы можете извлечь общую логику.

Кроме того автоматизируйте всё, что можно автоматизировать. Тогда ваш код останется бережливым.

Описанные выше шаги помогут повторно использовать код без необходимости копировать его.

## 5. Бритва Оккама

Создатель этого принципа - Уильям Оккам, философ 14 века. Принцип гласит, что в группе гипотез всегда выбирайте ту, которая имеет наименьшее количество предположений.

Следуя принципу бережливой разработки программного обеспечения, всегда начинайте с максимально простого кода. Затем осторожно увеличивайте сложность по мере необходимости.

Простой код позволяет легко представить, разработать, протестировать и исправить продукт на каждом этапе. Он также значительно сокращает количество ошибок, что позволяет программе работать быстрее.

## 6. Сначала большое проектирование (Big Design Up Front, BDUF)

Этот принцип разработки программного обеспечения утверждает, что разработчик должен сначала завершить проектирование. После этого проект можно реализовать.

Сторонники утверждают, что такой подход помогает обнаруживать проблемы на стадии требований и быстро их решать.

Однако изменения в требованиях к программному обеспечению могут произойти в течение жизненного цикла проекта. Такие изменения могут вызвать трудности или даже сделать дизайн проекта устаревшим.

Один из способов решить эту проблему - сначала создать общую архитектуру. Затем необходимо разделить требования на несколько этапов в соответствии с приоритетами. В процессе разработки начните с этапа с самым высоким приоритетом, постепенно опускаясь до самого низкого. На каждом этапе используйте этот принцип перед началом разработки.

## 7. Избегайте преждевременной оптимизации

Дональд Кнут утверждал, что корень всего зла в программировании - преждевременная оптимизация.

Мы все согласны с тем, что оптимизация ускоряет процесс разработки и снижает потребление ресурсов. Однако она приведёт к неприятным последствиям, если вы займётесь ей слишком рано.

Причина в том, что приоритизация кода занимает много времени и значительно усложняется, если делать её не вовремя. Кроме того, в процессе реализации наиболее оптимального решения требования могут измениться. Если это произойдет, ваша программа окажется в мусорной корзине или ее будет сложно изменить.

Поэтому начните с самого простого подхода, даже если он не самый оптимальный. Затем в дальнейшем оцените выбранный метод с точки зрения затрат ресурсов и времени. Основываясь на оценке, вы можете выбрать более быстрый алгоритм, который позволит потреблять меньше ресурсов или усилий.

## 8. Наименьшее удивление

Принцип наименьшего удивления гласит, что желательно разработать функцию, которая не имеет высокого коэффициента удивления.

Компоненты системы должны вести себя так, как того ожидают конечные пользователи. Поэтому результаты вашего проекта будут прибыльными только в том случае, если они очевидны, предсказуемы и последовательны.В противном случае пользователи будут уклоняться от использования функций или структур, которые удивляют или сбивают их с толку.

Вы создаёте программные продукты для людей. Таким образом, вы сильно выиграете от разработки удобных для пользователя функций. Стремитесь соответствовать ментальным моделям, опыту и ожиданиям людей.

Помните, что вы должны привлечь внимание пользователя как можно быстрее. Насколько нам известно, объем внимания современных пользователей резко упал.

## 9. Закон Деметры

Закон Деметры пытается разделить обязанности между классами и уменьшить связанность между ними.

**_Настоятельно рекомендуется:_**

- Обеспечить независимость программных объектов друг от друга. 
    

- Уменьшить общение или связь между разными классами.
    

- Поместить связанные классы в один и тот же пакет, модуль или каталог для достижения согласованности.
    

Следование этой идее позволит вашему приложению быть более удобным в обслуживании, понятным и гибким.

## 10. S.O.L.I.D 

Эта аббревиатура обозначает пять принципов объектно-ориентированного программирования и дизайна.

- S - Single Responsibility Principle (SRP) - Принцип единой ответственности.
    

- O - Open/Closed Principle (OCP) - Принцип открытия / закрытия.
    

- L - Liskov Substitution Principle - Принцип замещения Лисков.
    

- I - Interface Segregation Principle - Принцип разделения интерфейса.
    

- D - Dependency Inversion Principle - Принцип инверсии зависимостей.
    

**Давайте кратко рассмотрим каждый из этих принципов**

**_Принцип единой ответственности (SRP)_**

Это принцип разработки программного обеспечения, который гласит, что класс должен иметь только одну причину для изменения. Другими словами, у него должна быть только одна ответственность.

Здесь мы говорим о связанности. Все элементы в структурах или модулях данного класса должны иметь функциональное родство друг с другом. Чётко определив ответственность своего класса, вы повысите его связанность.

**_Принцип открытости / закрытости (OCP)_**

Принцип гласит, что вы должны иметь возможность изменять поведение класса, не изменяя сам класс.

Следовательно, вы можете расширить поведение класса за счет композиции, интерфейса и наследования. Однако вы не можете открыть класс для незначительных изменений.

**_Принцип замещения Лисков (LSP)_**

В своей исследовательской работе 1988 года Барбара Лисков заявила, что производные классы должны быть спроектированы так, чтобы их при необходимости можно было заменить своими базовыми классами без потери обратной совместимости. Таким образом, вам нужно проявлять осторожность при использовании наследования в проекте.

Хотя наследование выгодно, рекомендуется использовать его в контексте и умеренно. Принцип направлен на предотвращение случаев, когда классы расширяются только за счет общих вещей.

Перед выполнением наследования необходимо учитывать предварительные условия класса.

**_Принцип разделения интерфейса (ISP)_**

ISP предпочитает много конкретных интерфейсов одному общему. Цель состоит в том, чтобы иметь гранулярные и специфичные для клиента интерфейсы.

Вам необходимо повысить связанность в интерфейсах и разработать бережливые модули - с минимально возможным поведением.

Интерфейсы с множеством поведений сложно поддерживать и развивать. Так что вам следует избегать их.

**_Принцип инверсии зависимостей (DIP)_**

Принцип утверждает, что программисты должны полагаться на абстракции, а не на конкретные классы. Мы можем разбить это на две части:

- Модули высокого уровня должны быть независимыми от модулей низкого уровня. И те, и другие должны зависеть от абстракций
    

- Абстракции не должны зависеть от деталей реализации. Детали должны зависеть от абстракций.
    

Итак, в чем причина этого принципа? Ответ состоит в том, что абстракции мало меняются. Следовательно, вы можете легко изменить поведение вашего приватного или публичного кода. Таким образом, вы ускорите его дальнейшую эволюцию.
## 1. YAGNI

_You Aren’t Gonna Need It / Вам это не понадобится_  
  
Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.  
  
Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.  
  
Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.  
  

## 2. DRY

_Don’t Repeat Yourself / Не повторяйтесь_  
  
Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».  
  
Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?  
  

> В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.  
>   
> – Википедия

  
  
Использование SSOT позволит создать более прочную и понятную кодовую базу.  
  
Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.  
  
В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.  
  

## 3. KISS

_Keep It Simple, Stupid / Будь проще_  
  
Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.  
  
У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.  
  
Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.  
  
Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.  
  
Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.  
  

## 4. Big Design Up Front

_Глобальное проектирование прежде всего_  
  
Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.  
  
  
Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.  
  
Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.  
  
Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.  
  

## 5. SOLID

  
Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:  
  
**S) Single-responsibility principle /Принцип единственной ответственности**  
  
Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. 
  
Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.  
  
**O) Open–closed principle / Принцип открытости-закрытости**  
  
Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.  
  
Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.  
  
Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.  
  
**L) Liskov substitution principle / Принцип подстановки Лисков**  
  
Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.  
  
**I) Interface segregation principle / Принцип разделения интерфейсов**  
  
Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.  
  

> Объекты не должны зависеть от интерфейсов, которые они не используют

  
  
ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.  
  
Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:  
  

```
interface Animal {  eat: () => void;  walk: () => void;  fly: () => void;  swim: () => void;}
```

  
Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.  
  
**D) Dependency inversion principle / Принцип инверсии зависимостей**  
  
Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.  
  
Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.  
  
Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.  
  
В качестве примера взгляните на [date-io](https://github.com/dmtrKovalenko/date-io), в этой библиотеке создан тот уровень абстракции, который позволяет вам использовать её с разными источниками дат.  
  

## 6. Avoid Premature Optimization

_Избегайте преждевременной оптимизации_  
  
Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.  
  
Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали реализации, убедитесь, что эти оптимизации действительно полезны.  
  
Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.  
  
Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.  
  
Многие считают преждевременную оптимизацию корнем всех зол.  
  

## 7. Бритва Оккама

  

> Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, в кратком виде гласящий: «Не следует множить сущее без необходимости» (либо «Не следует привлекать новые сущности без крайней на то необходимости»).  
>   
> — Википедия

Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.