#собеседование #брокеры #сообщение 



# Kafka
## Упомяните, что такое Apache Kafka?
Apache Kafka — это система обмена сообщениями для публикации и подписки, разработанная Apache и написанная на Scala. Это распределенная, секционированная и реплицируемая служба журналов.
## Назовите традиционный метод передачи сообщений?

Традиционный метод передачи сообщений включает в себя два метода

- **В очереди:** В очереди пул потребителей может читать сообщение с сервера, и каждое сообщение отправляется одному из них.
- **Публикация-подписка:** В этой модели сообщения рассылаются всем потребителям.

Кафка обслуживает единую потребительскую абстракцию, которая обобщает оба вышеперечисленных понятия — группу потребителей.
## Укажите, в чем преимущества Apache Kafka по сравнению с традиционным методом?

Apache Kafka имеет следующие преимущества по сравнению с традиционной техникой обмена сообщениями.

- **Быстро:** Один брокер Kafka может обслуживать тысячи клиентов, обрабатывая мегабайты операций чтения и записи в секунду.
- **Масштабируемость:** Данные секционируются и оптимизируются по кластеру компьютеров, что позволяет хранить большие объемы данных.
- **Прочный:** Сообщения являются постоянными и реплицируются внутри кластера, чтобы предотвратить потерю данных.
- **Распространяется по дизайну:** Это обеспечивает гарантии отказоустойчивости и долговечности.
## Упомяните, что означает слово «брокер» в Кафке?

В кластере Kafka термин брокера используется для обозначения сервера.
## Укажите, какой максимальный размер сообщения может получить сервер Kafka?

Максимальный размер сообщения, которое может получить сервер Kafka, составляет 1000000 байт.
## Объясните, что такое Zookeeper в Кафке? Можем ли мы использовать Kafka без Zookeeper?

Zookeeper — это высокопроизводительная служба координации с открытым исходным кодом, используемая для распределенных приложений, адаптированных Kafka. Нет, невозможно обойти Zookeeper и подключиться напрямую к брокеру Kafka. Когда Zookeeper не работает, он не может обслуживать запросы клиентов.

- Zookeeper в основном используется для связи между различными узлами в кластере.
- В Kafka он используется для фиксации смещения, поэтому в случае сбоя узла в любом случае его можно получить из ранее зафиксированного смещения.
- Помимо этого, он также выполняет другие действия, такие как обнаружение лидеров, распределенная синхронизация, управление конфигурацией, определяет, когда новый узел покидает или присоединяется, кластер, состояние узла в реальном времени и т. д.
## Объясните, как сообщение воспринимается потребителем в Kafka?

Передача сообщений в Kafka осуществляется с помощью sendfile. [API](https://career.guru99.com/ru/top-20-questions-on-api-testing/ "API"). Он позволяет передавать байты из сокета на диск посредством копий, сохраняющих пространство ядра, и осуществлять обратный вызов ядра между пользователем ядра.
### Объясните, как можно улучшить пропускную способность удаленного потребителя?

Если потребитель находится в центре обработки данных, отличном от брокера, вам может потребоваться настроить размер буфера сокета, чтобы амортизировать длительную задержку в сети.
## Объясните, как можно получить ровно один раз сообщение от Кафки во время создания данных?

Во время обработки данных, чтобы получить ровно один раз сообщение от Кафки, вам необходимо выполнить две вещи. **избежание дубликатов во время потребления данных** и **избежание дублирования при производстве данных.** Вот два способа получить ровно одну семантику при создании данных:

1. Доступен один модуль записи для каждого раздела. Каждый раз, когда вы получаете сетевую ошибку, проверяется последнее сообщение в этом разделе, чтобы увидеть, была ли ваша последняя запись успешной.
2. В сообщении укажите первичный ключ (UUID или что-то в этом роде) и выполните дедупликацию на потребителе.
## Объясните, как можно уменьшить отток в ISR? Когда брокер покидает ISR?

ISR — это набор реплик сообщений, которые полностью синхронизированы с лидерами, другими словами, ISR содержит все зафиксированные сообщения. ISR всегда должен включать все реплики, пока не произойдет реальный сбой. Реплика будет исключена из ISR, если она отклонится от лидера.
## Зачем нужна репликация в Кафке?

Репликация сообщения в Kafka гарантирует, что любое опубликованное сообщение не потеряется и может быть использовано в случае машинной ошибки, ошибки программы или более распространенных обновлений программного обеспечения.
## Что означает, если реплика долгое время находится вне ISR?

Если реплика остается вне ISR в течение длительного времени, это указывает на то, что ведомый не может получать данные так же быстро, как данные, накопленные у лидера.
## Упомяните, что произойдет, если предпочитаемой реплики нет в ISR?

Если предпочтительная реплика отсутствует в ISR, контроллер не сможет переместиться. [руководство](https://career.guru99.com/ru/top-50-leadership-interview-questions/ "руководство") к предпочтительной реплике.
## Можно ли получить смещение сообщения после создания?

Вы не можете сделать это из класса, который ведет себя как производитель, как в большинстве систем очередей, его роль — запускать и забывать сообщения. Брокер выполнит остальную работу, например соответствующую обработку метаданных с идентификаторами, смещениями и т. д. Как потребитель сообщения, вы можете получить смещение от брокера Kafka. Если вы посмотрите в **Простойпотребитель** класс, вы заметите, что он приносит **МультиFetchResponse** объекты, включающие смещения в виде списка. В дополнение к этому, когда вы повторяете сообщение Кафки, у вас будет **СообщениеИСмещение** объекты, которые включают в себя как смещение, так и отправленное сообщение.
# RabbitMQ
## Что такое RabbitMQ и для чего используется

RabbitMQ — это брокер сообщений, который разработали в 2007 году на языке Erlang. 

Понять, что такое брокер, можно, представив обычную почту. Чтобы отправить письмо, не нужно передавать его прямо в руки получателю. Достаточно просто отнести его в почтовое отделение или опустить в почтовый ящик: вы можете быть уверены, что почтальон доставит письмо адресату. По сути RabbitMQ — это почтовый ящик, почтовое отделение и почтальон — посредник, который принимает, хранит и передает данные. 

Сообщение может содержать любые данные: информацию о процессе или задаче, которые должны запуститься в другом приложении (оно может находиться даже на другом сервере), или это может быть просто текст.

Сообщения накапливаются в очереди в брокере, и по мере работы системы получатели их запрашивают.
### **Особенности RabbitMQ**

RabbitMQ поддерживает несколько протоколов, включая AMQP (Advanced Message Queuing Protocol), MQTT (Message Queuing Telemetry Transport), STOMP (Simple Text Oriented Messaging Protocol), что делает его универсальным решением для широкого спектра задач. 

RabbitMQ гарантирует доставку сообщений получателю. Для этого используется механизм подтверждения доставки (Acknowledgements), который позволяет отправителю сообщения быть уверенным в том, что адресат его получил. Если получатель не подтверждает получение сообщения, RabbitMQ автоматически повторяет отправку.

Кроме этого, в RabbitMQ реализована пуш-модель получения сообщений, которая позволяет серверу активно отправлять информацию клиенту без запроса со стороны последнего. Это особенно полезно в ситуациях, когда нужно быстро информировать клиентов о важных событиях или изменениях в системе.
### **Для чего используют RabbitMQ**

Асинхронность — главная цель использования брокера сообщений. Асинхронный обмен предполагает отправку запроса или сообщения от одного сервиса к другому, при этом деятельность сервиса-отправителя не приостанавливается в ожидании ответа от получателя. 

Также брокер используется для:

- **Фоновой обработки данных.** RabbitMQ позволяет асинхронно обрабатывать большие объемы данных, что особенно полезно для задач, требующих значительных вычислительных ресурсов или времени на обработку. Например, генерации отчетов или обработки больших объемов данных.
- **Интеграции приложений и микросервисов.** RabbitMQ служит посредником между различными приложениями и микросервисами, позволяя им обмениваться данными и командами без прямого взаимодействия друг с другом. Это упрощает разработку и поддержку системы, делая ее более гибкой и масштабируемой.
- **Потоковой передачи данных в реальном времени.** RabbitMQ поддерживает потоковую передачу данных, что делает его идеальным инструментом для создания систем, работающих в реальном времени, таких как системы аналитики или финансовые системы.

RabbitMQ — это open-source-проект, который можно развернуть как локально, так и в облачной среде. На локальной машине RabbitMQ можно установить и настроить внутри корпоративной сети или на отдельном сервере. Это позволяет организациям полностью контролировать брокер сообщений и его настройки без передачи данных через внешние сети.

В облачной среде RabbitMQ также можно развернуть с использованием облачных провайдеров, таких как Yandex Cloud, Timeweb Cloud, VK Cloud.
## Как работает RabbitMQ

RabbitMQ состоит из нескольких основных компонентов: очередь (Queue), сообщение (Message), обменник (Exchange), биндинг (Binding), паблишер (Publisher), получатель (Consumer).

**Очередь (Queue)** — это структура данных, где хранятся сообщения до того, как получатель их обработает. Очередь может быть временной или постоянной, в зависимости от потребностей приложения.

**Сообщение (Message)** — это единица данных, которая передается от издателя к подписчику через очередь. Сообщения могут быть разных типов и форматов.

**Обменник (Exchange)** — это компонент, который принимает сообщения от издателей и направляет их в соответствующие очереди.

**Биндинг (Binding)** — это связь между обменником и очередью, которая определяет, какие сообщения в какую очередь будут направлены.

**Продюсер (Producer)** — это приложение, которое публикует сообщения в обменник.

**Получатель (Consumer)** — это приложение, которое получает сообщения из очереди и обрабатывает их.

Работа RabbitMQ происходит следующим образом:

- продюсер отправляет сообщение в обменник;
- обменник направляет сообщение в соответствующую очередь, в зависимости от типа обмена и биндинга;
- получатель подписывается на очередь и начинает получать сообщения из нее;
- получатель обрабатывает сообщения и выполняет необходимые действия;
- получатель подтверждает получение сообщения, чтобы исключить его из очереди;
- если сообщение не было подтверждено в течение определенного времени, оно будет повторно отправлено в очередь.
## Типичные сценарии

### Выполнение длительных операций

Представим себя интернет-проектом, который размещает у себя пользовательские видео или фото. Когда он получает по HTTP очередной файл, ему требуется сконвертировать его в стандартный формат для просмотра другими пользователями, а также, например, сделать несколько превью разного размера.

По-старинке эти операции делают последовательно в том же обработчике запроса, который и принял от пользователя файл. В схеме с брокером же после принятия файла он отправляет сообщение, в содержании которого будет, вероятно, ссылка на файла-оригинал, после чего он возвращает браузеру сообщение об успешной загрузке файла. Для отправки таких сообщений используют **прямую точку обмена**, с какой-то стандартной маршрутной меткой и соответствующим именем очереди, например `process_video` или `create_thumbnails`. Процессы, реализующие совершенно независимый сервис по выполнению этих длительных операций, будут по очереди забирать сообщения с "заданиями" из брокера, позволяя легко создавать любое количество исполнителей c **балансировкой нагрузки**, что обеспечит горизонтальное масштабирование этой подсистемы.

Еще один доступный механизм, который вписывается в эту задачу - **подтверждение о получении сообщения**_(acknowledgement)_. Получатель должен отправить брокеру дополнительное сообщение о том, что такое-то сообщение было успешно получено, в противном случае оно останется в очереди ожидать следующего получателя. Если процессы-исполнители будут подтверждать получение только после успешного выполнения длительной операции, это будет гарантировать, что все задания будут успешно выполнены вне зависимости от сбоев на каждом конкретном исполнителе, что обеспечивает **отказоустойчивость**.

### Удаленный вызов (RPC)

Для некоторых приложений важно не только отправить запрос на выполнение какой-то операции, но и получить в ответ какой-то результат. На самом деле использование брокера сообщений в этой ситуации не всегда является удачным решением, проще делать это напрямую посредством других технологий. Но если в системе итак присутствует брокер, а для удаленного вызова нет строгих требований по времени выполнения, плюс хочется подобно предыдущему примеру легко получить отказоустойчивость и балансировку нагрузки, то можно реализовать удаленный вызов и через брокер сообщений.

Для этого предусмотрено два заголовка сообщений:

- **Обратный адрес**_(reply to)_ - исполнитель должен отправить результат в очередь с указанным именем; отравитель сразу же после передачи сообщения-запроса брокеру начинает получать сообщения из указанной в этом заголовке очереди.
- **Идентификатор запроса**_(correlation id)_ - должен быть уникальным среди запросов, чтобы отправитель мог сопоставить результаты с запросами.

### Сообщения пользователям

Очереди можно использовать как входящие почтовые ящики для пользователей веб-приложений. Какие-то компоненты системы или другие пользователи с использованием _прямой точки обмена_ отправляют сообщения в очереди, содержащие в названии уникальный идентификатор пользователя-получателя. Там они ожидают пока он их не прочитает, например, зайдя на определенную страницу сайта.

В этом примере очень важно использовать режим постоянных сообщений _(persistant, путем установки заголовка `delivery_mode=2`)_, так как получатель сообщения может появиться очень не скоро и важно чтобы сообщения "переживали" даже полный перезапуск брокера сообщений. Для более короткоживущих сообщений это менее критично, но тоже порой актуально, особенно как еще одна мера для обеспечения **отказоустойчивости**.

Пример хоть и немного оторванный от реальности из-за очистки почтового ящика после каждого прочтения, но в каких-то ситуациях все же может иметь право на существование.

### Двустороннее соединение с браузером

Пожалуй, самый "вкусный" пример, хоть и лежащий на поверхности. На многих крупных [интернет-проектах](https://www.insight-it.ru/highload/), особенно социальной направленности можно увидеть уведомления _в реальном времени_ о событиях на сайте - кто-то что-то написал, поставил +1, проголосовал и т.п.

Реализация этого функционала требует довольно серьезной работы как на стороне браузера, так и на серверной стороне. Браузерный вопрос выходит за рамки этой статьи (хотя тут у меня тоже есть что рассказать, отдельным постом когда-нибудь обязательно напишу), а вот на серверной стороне брокер сообщений окажется очень даже кстати, особенно в реализации RabbitMQ.

На серверной части эта задача делится на две части:

- Поддерживать **постоянное соединение** со всеми пользователями, кто находится онлайн - здесь на помощь обычно приходит либо [Erlang](https://www.insight-it.ru/tag/erlang/), либо неблокирующий сервер на [epoll](https://www.insight-it.ru/tag/epoll/). Оба варианта очень неплохие, выбирайте сами.
- Дальше нужно как-то организовать **доставку сообщений** (информацию о событиях в системе) между пользователями, где и вступает в игру брокер. Обработчик соединения подписывается на сообщения о публичных событиях (точка обмена "отправить всем"), и туда же отправляет информацию о действиях пользователя-владельца.

Чем больше пользователей онлайн, тем больше сообщений в единицу времени будет проходить через брокер. Один сервер перестанет справляться довольно быстро, так что следующий раздел статьи окажется очень кстати.

## Кластеризация

Многое из вышеизложенного справедливо и для других реализаций [AMQP](https://www.insight-it.ru/tag/amqp/), но в вопросе кластеризации **RabbitMQ** предстает во всей красе. Залогом этого в первую очередь является использование [Erlang](https://www.insight-it.ru/tag/erlang/), не знаю почему я до сих пор не написал статью про этот язык программирования, здесь достаточно было бы на нее сослаться и все стало бы ясно.

Если вкратце, то в Erlang реализована внутренняя система легковесных процессов, не имеющая общего состояния и взаимодействующая друг с другом _исключительно_ посредством обменом сообщений. При этом с точки разработчика отправка сообщений другому процессу на том же физическом сервером и на удаленном выглядит одинаково, и даже является одним из операторов языка - "!", наравне с "=", "+" и.т.п. Этот факт позволяет приложениям или их частям взаимодействовать по сети так же легко, как и в рамках одного сервера.

Чтобы определить разрешено ли разным Erlang-сервера взаимодействовать друг с другом, они обмениваются хэшем пароля (который правда называют **cookie**, хотя с одноименным механизмом браузеров он ничего общего не имеет) и продолжают работу только если он совпал. Он должен быть одинаковым на всех узлах и хранится в файле `~/.erlang.cookie`, для RabbitMQ это обычно `/var/lib/rabbitmq/.erlang.cookie` - первым делом нужно решить этот вопрос, а также убедиться, что используется нестандартное значение.

Узлы в RabbitMQ кластере могут быть двух типов: работающие только **в памяти** и сохраняющие данные **на диск**. Так как состояние системы реплицируется между узлами кластера, в большинстве случаев достаточно иметь лишь 2-3 дисковых узла, а остальные избавить от необходимости работать с дисковой подсистемой для увеличения производительности.

Важно понимать, что под состоянием системы здесь имеются ввиду лишь привязки и настройки брокеров, каждая же очередь и хранящиеся в ней сообщения располагаются на одном конкретном узле, что приведет к потери части сообщений при сбое одного из серверов. Этот вопрос можно решить и средствами операционной системы, но чаще всего правильнее выделить критически-важные для системы очереди сообщений и включить их репликацию средствами RabbitMQ, этот механизм называется [**зеркальные очереди**](https://www.insight-it.ru/goto/3ff295d5/ "http://www.rabbitmq.com/ha.html")_(mirrored queues)_.  Репликация происходит по принципу **мастер-слуга**_(master-slave)_, как и в реляционных СУБД: все операции осуществляются на основном сервере (мастере), он транслирует их на один или несколько вторичных серверов (слуги), при каком-либо сбое на основном один из слуг "повышается" до статуса мастера и берет на себя его функции. Очереди могут быть объявлены зеркальными только при создании, но новые узлы в роли слуг могут добавляться и позже, в таком случае новый слуга начнет получать входящие сообщения и рано или поздно начнет полностью отражать его состояние, механизма синхронизации при подключении дополнительного слуги не предусмотрено. Последним шагом для гарантированной доставки сообщений, не упоминавшимся ранее, является механизм **уведомления отправителя об успешной записи сообщения** в очередь (на все сервера для зеркальных).

В кластерном окружении может понадобиться **объединение точек обмена**_(exchange federation)_, что реализуется посредством пересылки сообщений по однонаправленным связям. При этом учитывается наличие на принимающей стороне очередей, готовых принять каждое конкретное сообщение. Практического применения в веб-проектах этому пока особо не вижу, разве что при кросс-датацентровой работе. Кстати, для этого поддерживается работа поверх [SSL](https://www.insight-it.ru/goto/c397c12c/ "http://www.rabbitmq.com/ssl.html").

Для подключения узлов к кластеру можно использовать консольную утилиту (для временных изменений) или конфигурационные файлы (для постоянных настроек), подробно [останавливаться не буду](https://www.insight-it.ru/goto/db4a1208/ "http://www.rabbitmq.com/clustering.html").